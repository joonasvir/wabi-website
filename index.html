<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wabi — The first personal software platform</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      color: #111;
      background: #fff;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Nav */
    nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px 32px;
      position: sticky;
      top: 0;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 100;
    }

    .nav-logo svg {
      height: 24px;
      width: auto;
    }

    .nav-right {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .nav-right a {
      color: #555;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
    }

    .nav-right a:hover {
      color: #111;
    }

    .btn-outline {
      display: inline-flex;
      align-items: center;
      padding: 8px 18px;
      border: 1.5px solid #222;
      border-radius: 100px;
      font-size: 14px;
      font-weight: 500;
      color: #111;
      text-decoration: none;
      transition: background 0.2s, color 0.2s;
    }

    .btn-outline:hover {
      background: #111;
      color: #fff;
    }

    /* Sections */
    section {
      padding: 80px 24px;
      text-align: center;
    }

    .section-badge {
      display: inline-flex;
      align-items: center;
      padding: 6px 14px;
      border: 1px solid #e0e0e0;
      border-radius: 100px;
      font-size: 13px;
      font-weight: 500;
      color: #444;
      margin-bottom: 20px;
    }

    .section-heading {
      font-size: 36px;
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 16px;
      letter-spacing: -0.02em;
    }

    .section-sub {
      font-size: 16px;
      color: #666;
      max-width: 480px;
      margin: 0 auto;
      line-height: 1.5;
    }

    /* Hero */
    .hero {
      padding: 100px 24px 60px;
    }

    .hero-heading {
      font-size: 44px;
      font-weight: 700;
      line-height: 1.15;
      letter-spacing: -0.03em;
      max-width: 520px;
      margin: 0 auto 40px;
    }

    /* Waitlist form */
    .waitlist-form {
      display: inline-flex;
      align-items: center;
      border: 1.5px solid #ddd;
      border-radius: 100px;
      padding: 5px 5px 5px 20px;
      gap: 8px;
      background: #fff;
      max-width: 380px;
      width: 100%;
    }

    .waitlist-form input {
      border: none;
      outline: none;
      font-family: inherit;
      font-size: 14px;
      color: #111;
      flex: 1;
      min-width: 0;
      background: transparent;
    }

    .waitlist-form input::placeholder {
      color: #aaa;
    }

    .waitlist-form button {
      padding: 10px 20px;
      background: #111;
      color: #fff;
      border: none;
      border-radius: 100px;
      font-family: inherit;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.2s;
    }

    .waitlist-form button:hover {
      background: #333;
    }

    /* Meet Wabi */
    .meet-wabi {
      padding: 80px 24px 60px;
    }

    .meet-heading {
      font-size: 32px;
      font-weight: 700;
      line-height: 1.25;
      letter-spacing: -0.02em;
      margin-bottom: 16px;
    }

    .plus-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 56px;
      height: 56px;
      border: 1.5px solid #ddd;
      border-radius: 50%;
      margin-top: 32px;
      cursor: pointer;
      transition: border-color 0.2s, box-shadow 0.2s;
      background: #fff;
    }

    .plus-btn:hover {
      border-color: #aaa;
      box-shadow: 0 2px 12px rgba(0,0,0,0.08);
    }

    .plus-btn svg {
      width: 22px;
      height: 22px;
      color: #333;
    }

    /* Create section cards */
    .create-cards {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 0;
      margin-top: 40px;
      position: relative;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      height: 380px;
    }

    .create-card {
      border-radius: 20px;
      overflow: hidden;
      position: absolute;
    }

    .create-card-1 {
      width: 200px;
      height: 260px;
      left: 40px;
      bottom: 0;
      background: linear-gradient(135deg, #f8c4d8 0%, #e8a0c0 30%, #c88aa8 60%, #8b6090 80%, #5a4070 100%);
      z-index: 1;
    }

    .create-card-2 {
      width: 260px;
      height: 340px;
      left: 50%;
      transform: translateX(-50%);
      bottom: 0;
      background: #fff;
      border: 1px solid #eee;
      box-shadow: 0 8px 40px rgba(0,0,0,0.12);
      z-index: 2;
      display: flex;
      flex-direction: column;
    }

    .card-app-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 16px 16px 0;
      font-size: 11px;
      color: #999;
    }

    .card-app-header .dot {
      width: 6px;
      height: 6px;
      background: #ccc;
      border-radius: 50%;
    }

    .card-app-title {
      padding: 10px 16px 4px;
      font-size: 12px;
      color: #999;
    }

    .card-app-name {
      padding: 0 16px;
      font-size: 20px;
      font-weight: 700;
      color: #111;
    }

    .card-app-desc {
      padding: 8px 16px;
      font-size: 12px;
      color: #888;
      line-height: 1.4;
    }

    .card-app-image {
      flex: 1;
      margin: 8px 16px 0;
      border-radius: 12px;
      background: linear-gradient(160deg, #8ba, #4a7, #5a8);
      min-height: 80px;
    }

    .card-app-input {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 12px 16px 16px;
      padding: 10px 14px;
      background: #f5f5f5;
      border-radius: 12px;
      font-size: 13px;
      color: #999;
    }

    .card-app-input .send-icon {
      margin-left: auto;
      width: 28px;
      height: 28px;
      background: #111;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .create-card-3 {
      width: 200px;
      height: 260px;
      right: 40px;
      bottom: 0;
      background: linear-gradient(135deg, #c8d8c0 0%, #90a888 50%, #607850 100%);
      z-index: 1;
    }

    /* Discover section pills */
    .category-pills {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 32px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      border-radius: 100px;
      font-size: 14px;
      font-weight: 500;
      border: 1.5px solid #e0e0e0;
      color: #444;
      background: #fff;
      cursor: pointer;
      transition: all 0.2s;
    }

    .pill:hover {
      border-color: #bbb;
    }

    .pill.active {
      background: #111;
      color: #fff;
      border-color: #111;
    }

    .pill-icon {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Friends mockup */
    .friends-mockup {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      margin-top: 40px;
      padding: 24px 32px;
      background: #fafafa;
      border-radius: 24px;
      border: 1px solid #eee;
    }

    .friends-badge-count {
      font-size: 12px;
      color: #666;
      background: #fff;
      border: 1px solid #eee;
      border-radius: 100px;
      padding: 4px 12px;
      margin-bottom: 16px;
    }

    .friend-avatars {
      display: flex;
      align-items: center;
    }

    .friend-avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 3px solid #fff;
      margin-left: -10px;
    }

    .friend-avatar:first-child {
      margin-left: 0;
    }

    .friends-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 16px;
    }

    .invite-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #111;
      color: #fff;
      border: none;
      border-radius: 100px;
      font-family: inherit;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
    }

    .settings-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1.5px solid #ddd;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* Integrations */
    .integrations-text {
      font-size: 22px;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    /* Final CTA */
    .cta-section {
      padding: 100px 24px;
    }

    .cta-heading {
      font-size: 40px;
      font-weight: 700;
      line-height: 1.15;
      letter-spacing: -0.03em;
      max-width: 480px;
      margin: 0 auto 20px;
    }

    /* Footer */
    footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 24px 32px;
      border-top: 1px solid #f0f0f0;
      font-size: 12px;
      color: #999;
    }

    .footer-logo svg {
      height: 18px;
      width: auto;
    }

    .footer-links {
      display: flex;
      gap: 24px;
    }

    .footer-links a {
      color: #999;
      text-decoration: none;
      font-size: 12px;
    }

    .footer-links a:hover {
      color: #555;
    }

    /* Divider */
    .section-divider {
      height: 1px;
      background: #f0f0f0;
      max-width: 800px;
      margin: 0 auto;
    }

    /* Orb Playground */
    .orb-playground {
      position: relative;
      width: 100%;
      height: 600px;
      overflow: hidden;
      cursor: pointer;
      background: #fff;
    }

    .orb-playground canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .orb-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px;
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid #e8e8e8;
      border-radius: 100px;
      z-index: 10;
      box-shadow: 0 2px 16px rgba(0,0,0,0.06);
    }

    .orb-ctrl-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      border: 1.5px solid transparent;
      border-radius: 100px;
      font-family: inherit;
      font-size: 13px;
      font-weight: 500;
      color: #555;
      background: transparent;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .orb-ctrl-btn:hover {
      background: #f0f0f0;
      color: #111;
    }

    .orb-ctrl-btn.active {
      background: #111;
      color: #fff;
      border-color: #111;
    }

    .orb-ctrl-btn svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .orb-ctrl-divider {
      width: 1px;
      height: 24px;
      background: #e0e0e0;
      flex-shrink: 0;
    }

    .orb-count {
      position: absolute;
      top: 20px;
      left: 24px;
      font-size: 13px;
      color: #999;
      pointer-events: none;
      user-select: none;
    }

    .orb-count span {
      font-size: 36px;
      font-weight: 700;
      color: #111;
      display: block;
      margin-top: 2px;
    }

    .orb-mode-label {
      position: absolute;
      top: 20px;
      right: 24px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #aaa;
      pointer-events: none;
      user-select: none;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .orb-playground {
        height: 480px;
      }

      .orb-controls {
        gap: 4px;
        padding: 4px;
        flex-wrap: nowrap;
        max-width: calc(100% - 32px);
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }

      .orb-controls::-webkit-scrollbar { display: none; }

      .orb-ctrl-btn {
        padding: 7px 12px;
        font-size: 12px;
      }

      .orb-ctrl-btn svg {
        width: 14px;
        height: 14px;
      }
    }

    @media (max-width: 640px) {
      .hero-heading {
        font-size: 32px;
      }

      .section-heading {
        font-size: 28px;
      }

      .cta-heading {
        font-size: 30px;
      }

      .meet-heading {
        font-size: 26px;
      }

      .create-cards {
        height: 280px;
      }

      .create-card-1 {
        width: 140px;
        height: 180px;
        left: 10px;
      }

      .create-card-2 {
        width: 200px;
        height: 260px;
      }

      .create-card-3 {
        width: 140px;
        height: 180px;
        right: 10px;
      }

      nav {
        padding: 16px 20px;
      }

      footer {
        flex-direction: column;
        gap: 16px;
      }
    }
  </style>
</head>
<body>

  <!-- Nav -->
  <nav>
    <a href="/" class="nav-logo">
      <svg viewBox="0 0 120 28" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M4 8C4 8 8 20 10 20C12 20 14 12 16 12C18 12 20 20 22 20C24 20 28 8 28 8" stroke="#111" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
        <text x="36" y="21" font-family="Inter, sans-serif" font-weight="600" font-size="18" fill="#111">wabi</text>
      </svg>
    </a>
    <div class="nav-right">
      <a href="#">Read our manifesto</a>
      <a href="#" class="btn-outline">Get the app</a>
    </div>
  </nav>

  <!-- Hero -->
  <section class="hero">
    <h1 class="hero-heading">A new era of software is here.</h1>
    <form class="waitlist-form" onsubmit="return false;">
      <input type="email" placeholder="name@email.com" />
      <button type="submit">Join waitlist</button>
    </form>
  </section>

  <!-- Meet Wabi -->
  <section class="meet-wabi">
    <h2 class="meet-heading">Meet Wabi.<br>The first personal software platform.</h2>
    <p class="section-sub">Create, discover, and remix any mini-app in minutes</p>
    <div class="plus-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="12" y1="5" x2="12" y2="19"/>
        <line x1="5" y1="12" x2="19" y2="12"/>
      </svg>
    </div>
  </section>

  <!-- Create -->
  <section>
    <span class="section-badge">Create</span>
    <h2 class="section-heading">Create anything</h2>
    <p class="section-sub">Go from idea to app in a snap. That thing you wished existed? Make it.</p>
    <div class="create-cards">
      <div class="create-card create-card-1"></div>
      <div class="create-card create-card-2">
        <div class="card-app-header">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span style="margin-left: 8px;">Art Masters Quiz</span>
        </div>
        <div class="card-app-title">Impressionist painter</div>
        <div class="card-app-name">Claude Monet</div>
        <div class="card-app-desc">Oscar-Claude Monet was a French painter and founder of impressionist painting...</div>
        <div class="card-app-image"></div>
        <div class="card-app-input">
          Make any changes...
          <span class="send-icon">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="22" y1="2" x2="11" y2="13"/>
              <polygon points="22 2 15 22 11 13 2 9 22 2"/>
            </svg>
          </span>
        </div>
      </div>
      <div class="create-card create-card-3"></div>
    </div>
  </section>

  <!-- Discover -->
  <section>
    <span class="section-badge">Discover</span>
    <h2 class="section-heading">Discover and remix</h2>
    <p class="section-sub">Explore thousands of free apps made by people like you</p>
    <div class="category-pills">
      <span class="pill active">
        <span class="pill-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10"/><path d="M2 12h20"/></svg>
        </span>
        Essentials
      </span>
      <span class="pill">
        <span class="pill-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg>
        </span>
        Lifestyle
      </span>
      <span class="pill">
        <span class="pill-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>
        </span>
        Health
      </span>
      <span class="pill">
        <span class="pill-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
        </span>
        Fitness
      </span>
      <span class="pill">
        <span class="pill-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M12 2a10 10 0 0 1 0 20 10 10 0 0 1 0-20z"/></svg>
        </span>
        Cooking
      </span>
      <span class="pill">
        <span class="pill-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>
        </span>
        Tracking
      </span>
    </div>
  </section>

  <!-- Remix -->
  <section>
    <span class="section-badge">Remix</span>
    <h2 class="section-heading">Remix everything</h2>
    <p class="section-sub">Take any app and make it yours</p>
  </section>

  <!-- Multiplayer -->
  <section>
    <span class="section-badge">Multiplayer</span>
    <h2 class="section-heading">Add your friends</h2>
    <p class="section-sub">Apps are better when they're shared. Invite your friends to your app. Wabi is social by design.</p>
    <div class="friends-mockup">
      <span class="friends-badge-count">4 friends added!</span>
      <div class="friend-avatars">
        <div class="friend-avatar" style="background: linear-gradient(135deg, #f0c27f, #fc5c7d);"></div>
        <div class="friend-avatar" style="background: linear-gradient(135deg, #a18cd1, #fbc2eb);"></div>
        <div class="friend-avatar" style="background: linear-gradient(135deg, #ffecd2, #fcb69f);"></div>
        <div class="friend-avatar" style="background: linear-gradient(135deg, #84fab0, #8fd3f4);"></div>
      </div>
      <div class="friends-actions">
        <button class="invite-btn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="8.5" cy="7" r="4"/><line x1="20" y1="8" x2="20" y2="14"/><line x1="23" y1="11" x2="17" y2="11"/></svg>
          Invite friends
        </button>
        <button class="settings-btn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
        </button>
      </div>
    </div>
  </section>

  <!-- Integrations -->
  <section>
    <p class="integrations-text">20+ integrations, and hundred to come</p>
  </section>

  <!-- Final CTA -->
  <section class="cta-section">
    <h2 class="cta-heading">Welcome to the era<br>of personal software</h2>
    <p class="section-sub" style="margin-bottom: 32px;">Where anyone can create, discover, remix, and share mini-apps — no code required.</p>
    <form class="waitlist-form" onsubmit="return false;">
      <input type="email" placeholder="name@email.com" />
      <button type="submit">Join waitlist</button>
    </form>
  </section>

  <!-- Orb Playground -->
  <div class="orb-playground" id="orbPlayground">
    <canvas id="orbCanvas"></canvas>
    <div class="orb-count">
      Apps created<span id="orbCount">0</span>
    </div>
    <div class="orb-mode-label" id="orbModeLabel"></div>
    <div class="orb-controls">
      <button class="orb-ctrl-btn" id="btnDrop" title="Drop an orb">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        Drop
      </button>
      <div class="orb-ctrl-divider"></div>
      <button class="orb-ctrl-btn active" id="btnPhysics" title="Physics mode">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="12" y1="16" x2="14" y2="14"/></svg>
        Physics
      </button>
      <button class="orb-ctrl-btn" id="btnCyclone" title="Cyclone mode">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.9 0 1.8-.1 2.6-.4"/><path d="M12 8a4 4 0 1 0 4 4"/><circle cx="12" cy="12" r="1"/></svg>
        Cyclone
      </button>
      <button class="orb-ctrl-btn" id="btnShapes" title="Shapes mode">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polygon points="12 2 22 20 2 20"/></svg>
        Shapes
      </button>
      <button class="orb-ctrl-btn" id="btnMoon" title="Moon gravity">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
        Moon
      </button>
      <div class="orb-ctrl-divider"></div>
      <button class="orb-ctrl-btn" id="btnClear" title="Clear all orbs">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        Clear
      </button>
    </div>
  </div>

  <!-- Footer -->
  <footer>
    <a href="/" class="footer-logo">
      <svg viewBox="0 0 120 28" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M4 8C4 8 8 20 10 20C12 20 14 12 16 12C18 12 20 20 22 20C24 20 28 8 28 8" stroke="#999" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
        <text x="36" y="21" font-family="Inter, sans-serif" font-weight="600" font-size="18" fill="#999">wabi</text>
      </svg>
    </a>
    <div class="footer-links">
      <a href="#">Privacy policy</a>
      <a href="#">Terms of service</a>
    </div>
  </footer>

  <script>
  (function() {
    const WABI_API_URL = 'https://api.wabi.ai/api/v1/app/random-covers?count=30';
    const FALLBACK_ORBS = [
      'https://i.imgur.com/4Aq1p5V.png','https://i.imgur.com/qx8f4iH.png','https://i.imgur.com/AWPO3TG.png',
      'https://i.imgur.com/p9lsZOd.png','https://i.imgur.com/vwH7fhY.png','https://i.imgur.com/LMjFvVQ.png',
      'https://i.imgur.com/SfPZogI.png','https://i.imgur.com/4MhFEwN.png','https://i.imgur.com/cv5FCFY.png',
      'https://i.imgur.com/D5A4UUJ.png','https://i.imgur.com/PFsPgBN.png','https://i.imgur.com/B70veGi.png',
      'https://i.imgur.com/AehAw57.png','https://i.imgur.com/rwgRwAj.png','https://i.imgur.com/ojY9Fs3.png',
      'https://i.imgur.com/SU1ihwl.png','https://i.imgur.com/ct0AeRD.png','https://i.imgur.com/0uZCyTe.png',
      'https://i.imgur.com/8dKpawM.png','https://i.imgur.com/EBMFd7A.png','https://i.imgur.com/34OFX6f.png',
      'https://i.imgur.com/nh6p2J0.png','https://i.imgur.com/9GEdegS.png','https://i.imgur.com/IUMWj6Y.png',
      'https://i.imgur.com/etdgUOx.png','https://i.imgur.com/6LgF0YR.png','https://i.imgur.com/7MqgR3i.png',
      'https://i.imgur.com/txHoBrO.png','https://i.imgur.com/iV88FY2.png','https://i.imgur.com/FAoVMHq.png',
    ];
    const BASE_RADIUS = 42;
    const MIN_SCALE = 0.9;
    const MAX_SCALE = 1.1;
    const SHAPES = ['triangle','circle','square','hexagon','heart','diamond','star','spiral','grid','wave'];
    const DAMPING = 0.005;

    const container = document.getElementById('orbPlayground');
    const canvas = document.getElementById('orbCanvas');
    const countEl = document.getElementById('orbCount');
    const modeLabel = document.getElementById('orbModeLabel');
    const btnDrop = document.getElementById('btnDrop');
    const btnPhysics = document.getElementById('btnPhysics');
    const btnCyclone = document.getElementById('btnCyclone');
    const btnShapes = document.getElementById('btnShapes');
    const btnMoon = document.getElementById('btnMoon');
    const btnClear = document.getElementById('btnClear');

    let engine, walls = [];
    let orbDataMap = new Map();
    let preloadedImages = new Map();
    let coverUrls = [];
    let overlayImage = null;
    let orbAnimData = new Map();
    let displayMode = 'physics';
    let moonMode = false;
    let currentShape = 0;
    let cycloneTime = 0;
    let cycloneFocalAngle = 0;
    let animationId;
    let mouseConstraint;

    function getContainerRect() {
      return container.getBoundingClientRect();
    }

    async function fetchCovers() {
      try {
        const res = await fetch(WABI_API_URL);
        if (!res.ok) throw new Error();
        const json = await res.json();
        const urls = json.data?.covers || [];
        if (urls.length > 0) return urls;
      } catch(e) {}
      return [];
    }

    async function preloadImages() {
      const urls = await fetchCovers();
      coverUrls = urls;
      const all = [...urls, ...FALLBACK_ORBS];
      await Promise.all(all.map(url => new Promise(resolve => {
        if (preloadedImages.has(url)) return resolve();
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { preloadedImages.set(url, img); resolve(); };
        img.onerror = () => resolve();
        img.src = url;
      })));
    }

    function getRandomCover() {
      const urls = coverUrls.length > 0 ? coverUrls : FALLBACK_ORBS;
      return urls[Math.floor(Math.random() * urls.length)];
    }

    function updateCount() {
      const n = Matter.Composite.allBodies(engine.world).filter(b => b.label === 'orb').length;
      countEl.textContent = n;
    }

    function updateModeLabel() {
      if (displayMode === 'cyclone') modeLabel.textContent = 'CYCLONE';
      else if (displayMode === 'shapes') modeLabel.textContent = SHAPES[currentShape].toUpperCase();
      else if (moonMode) modeLabel.textContent = 'MOON';
      else modeLabel.textContent = '';
    }

    function setActiveBtn(activeId) {
      [btnPhysics, btnCyclone, btnShapes].forEach(b => b.classList.remove('active'));
      document.getElementById(activeId)?.classList.add('active');
    }

    function addOrb(x) {
      const rect = getContainerRect();
      const w = rect.width;
      const h = rect.height;
      const scale = MIN_SCALE + Math.random() * (MAX_SCALE - MIN_SCALE);
      const radius = BASE_RADIUS * scale;
      const posX = x !== undefined ? x : Math.random() * (w - radius * 2) + radius;
      const posY = -radius * 2;
      const imageUrl = getRandomCover();

      const orb = Matter.Bodies.circle(posX, posY, radius, {
        restitution: 0.8,
        friction: 0.05,
        frictionAir: DAMPING,
        density: 0.001,
        label: 'orb',
        slop: 0.01,
        sleepThreshold: 30,
      });

      const data = {
        imageUrl: imageUrl,
        image: preloadedImages.get(imageUrl) || null,
      };

      if (!data.image) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { data.image = img; preloadedImages.set(imageUrl, img); };
        img.src = imageUrl;
      }

      orbDataMap.set(orb.id, data);
      Matter.Composite.add(engine.world, orb);
      updateCount();
    }

    function clearOrbs() {
      Matter.Composite.allBodies(engine.world).filter(b => b.label === 'orb').forEach(orb => {
        orbDataMap.delete(orb.id);
        orbAnimData.delete(orb.id);
        Matter.Composite.remove(engine.world, orb);
      });
      updateCount();
    }

    function setMode(mode) {
      if (mode === 'shapes' && displayMode === 'shapes') {
        currentShape = (currentShape + 1) % SHAPES.length;
      }
      displayMode = mode;
      if (mode === 'physics') {
        engine.gravity.y = moonMode ? -0.4 : 1;
        // Unfreeze all orbs
        Matter.Composite.allBodies(engine.world).filter(b => b.label === 'orb').forEach(b => {
          Matter.Body.setStatic(b, false);
          Matter.Sleeping.set(b, false);
        });
      }
      setActiveBtn(mode === 'physics' ? 'btnPhysics' : mode === 'cyclone' ? 'btnCyclone' : 'btnShapes');
      updateModeLabel();
    }

    function toggleMoon() {
      moonMode = !moonMode;
      btnMoon.classList.toggle('active', moonMode);
      if (displayMode === 'physics') {
        engine.gravity.y = moonMode ? -0.4 : 1;
      }
      updateModeLabel();
    }

    function generateShapePositions(shape, count, centerX, centerY, maxW, maxH) {
      const positions = [];
      if (count === 0) return positions;
      const padding = 60;
      const maxWidth = maxW - padding * 2;
      const maxHeight = maxH - padding * 2;
      const orbSize = BASE_RADIUS * 2.2;

      function scaleToFit(pts) {
        if (!pts.length) return pts;
        let minX = Infinity, maxX2 = -Infinity, minY = Infinity, maxY2 = -Infinity;
        pts.forEach(p => { minX = Math.min(minX, p.x); maxX2 = Math.max(maxX2, p.x); minY = Math.min(minY, p.y); maxY2 = Math.max(maxY2, p.y); });
        const w = maxX2 - minX + orbSize;
        const h = maxY2 - minY + orbSize;
        const s = Math.min(1, maxWidth / w, maxHeight / h);
        const ox = (minX + maxX2) / 2;
        const oy = (minY + maxY2) / 2;
        return pts.map(p => ({ x: centerX + (p.x - ox) * s, y: centerY + (p.y - oy) * s }));
      }

      if (shape === 'circle') {
        const r = Math.max(orbSize, count * orbSize / (2 * Math.PI));
        for (let i = 0; i < count; i++) { const a = (i / count) * Math.PI * 2 - Math.PI / 2; positions.push({ x: Math.cos(a) * r, y: Math.sin(a) * r }); }
      } else if (shape === 'triangle') {
        const rows = Math.ceil((-1 + Math.sqrt(1 + 8 * count)) / 2); let idx = 0;
        for (let row = 0; row < rows && idx < count; row++) { const rc = row + 1; for (let col = 0; col < rc && idx < count; col++) { positions.push({ x: (col - rc / 2 + 0.5) * orbSize, y: (row - rows / 2 + 0.5) * orbSize }); idx++; } }
      } else if (shape === 'square') {
        const side = Math.ceil(Math.sqrt(count)); let idx = 0;
        for (let r = 0; r < side && idx < count; r++) for (let c = 0; c < side && idx < count; c++) { positions.push({ x: (c - side / 2 + 0.5) * orbSize, y: (r - side / 2 + 0.5) * orbSize }); idx++; }
      } else if (shape === 'hexagon') {
        let placed = 0, ring = 0;
        while (placed < count) { if (ring === 0) { positions.push({ x: 0, y: 0 }); placed++; } else { const rc = ring * 6; for (let i = 0; i < rc && placed < count; i++) { const a = (i / rc) * Math.PI * 2 - Math.PI / 2; positions.push({ x: Math.cos(a) * ring * orbSize, y: Math.sin(a) * ring * orbSize }); placed++; } } ring++; }
      } else if (shape === 'heart') {
        for (let i = 0; i < count; i++) { const t = (i / count) * Math.PI * 2; positions.push({ x: 16 * Math.pow(Math.sin(t), 3) * 8, y: -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 8 }); }
      } else if (shape === 'diamond') {
        const size = Math.ceil(Math.sqrt(count * 2)); let idx = 0;
        for (let r = 0; r < size && idx < count; r++) { const rw = r < size / 2 ? r + 1 : size - r; for (let c = 0; c < rw && idx < count; c++) { positions.push({ x: (c - rw / 2 + 0.5) * orbSize, y: (r - size / 2 + 0.5) * orbSize }); idx++; } }
      } else if (shape === 'star') {
        const pts = 5; const outerR = Math.max(orbSize * 2, count * orbSize / (pts * 2)); const innerR = outerR * 0.4;
        for (let i = 0; i < count; i++) { const a = (i / count) * Math.PI * 2 - Math.PI / 2; const isO = Math.floor(i * pts * 2 / count) % 2 === 0; positions.push({ x: Math.cos(a) * (isO ? outerR : innerR), y: Math.sin(a) * (isO ? outerR : innerR) }); }
      } else if (shape === 'spiral') {
        const turns = Math.max(2, count / 8);
        for (let i = 0; i < count; i++) { const t = (i / count) * turns * Math.PI * 2; const r = (i / count) * Math.min(maxWidth, maxHeight) * 0.4; positions.push({ x: Math.cos(t) * r, y: Math.sin(t) * r }); }
      } else if (shape === 'grid') {
        const cols = Math.ceil(Math.sqrt(count * (maxWidth / maxHeight))); const rows = Math.ceil(count / cols); let idx = 0;
        for (let r = 0; r < rows && idx < count; r++) for (let c = 0; c < cols && idx < count; c++) { positions.push({ x: (c - cols / 2 + 0.5) * orbSize, y: (r - rows / 2 + 0.5) * orbSize }); idx++; }
      } else if (shape === 'wave') {
        const cols = Math.ceil(Math.sqrt(count * 2)); const rows = Math.ceil(count / cols); let idx = 0;
        for (let r = 0; r < rows && idx < count; r++) for (let c = 0; c < cols && idx < count; c++) { positions.push({ x: (c - cols / 2 + 0.5) * orbSize, y: (r - rows / 2 + 0.5) * orbSize + Math.sin(c * 0.8) * orbSize * 1.5 }); idx++; }
      }
      return scaleToFit(positions);
    }

    async function init() {
      await preloadImages();

      // Load overlay
      await new Promise(resolve => {
        const img = new Image();
        img.onload = () => { overlayImage = img; resolve(); };
        img.onerror = () => resolve();
        img.src = '/orb-overlay.png';
      });

      const rect = getContainerRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);

      engine = Matter.Engine.create({ gravity: { x: 0, y: 1 }, enableSleeping: true });
      engine.positionIterations = 6;
      engine.velocityIterations = 4;

      const wallT = 50;
      const w = rect.width;
      const h = rect.height;
      walls = [
        Matter.Bodies.rectangle(w / 2, h + wallT / 2, w * 2, wallT, { isStatic: true, label: 'wall' }),
        Matter.Bodies.rectangle(-wallT / 2, h / 2, wallT, h * 2, { isStatic: true, label: 'wall' }),
        Matter.Bodies.rectangle(w + wallT / 2, h / 2, wallT, h * 2, { isStatic: true, label: 'wall' }),
      ];
      Matter.Composite.add(engine.world, walls);

      // Mouse constraint
      const mouse = Matter.Mouse.create(canvas);
      mouseConstraint = Matter.MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: { stiffness: 0.2, render: { visible: false } },
      });
      mouse.pixelRatio = dpr;
      Matter.Composite.add(engine.world, mouseConstraint);

      // Click to add orb (if not clicking an existing one)
      let mouseDownTime = 0;
      let mouseDownPos = { x: 0, y: 0 };
      let mouseDownBody = null;

      Matter.Events.on(mouseConstraint, 'mousedown', () => {
        mouseDownTime = Date.now();
        mouseDownPos = { x: mouse.position.x, y: mouse.position.y };
        mouseDownBody = mouseConstraint.body;
      });

      Matter.Events.on(mouseConstraint, 'mouseup', () => {
        const elapsed = Date.now() - mouseDownTime;
        const dx = mouse.position.x - mouseDownPos.x;
        const dy = mouse.position.y - mouseDownPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (elapsed < 200 && dist < 10 && !mouseDownBody) {
          addOrb(mouse.position.x);
        }
        mouseDownBody = null;
      });

      // Drop a few orbs to start
      for (let i = 0; i < 5; i++) {
        setTimeout(() => addOrb(), i * 200);
      }

      function render() {
        const rect = getContainerRect();
        const w = rect.width;
        const h = rect.height;
        const centerX = w / 2;
        const centerY = h / 2;

        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);

        const orbs = Matter.Composite.allBodies(engine.world).filter(b => b.label === 'orb');

        if (displayMode === 'cyclone') {
          cycloneTime += 0.016;
          cycloneFocalAngle += 0.003;
        }

        if (displayMode === 'shapes') {
          const shape = SHAPES[currentShape];
          const positions = generateShapePositions(shape, orbs.length, centerX, centerY, w, h);
          orbs.forEach((body, i) => {
            if (i < positions.length) {
              let ad = orbAnimData.get(body.id);
              if (!ad) { ad = { angle: 0, radius: 0, speed: 0 }; orbAnimData.set(body.id, ad); }
              ad.targetX = positions[i].x;
              ad.targetY = positions[i].y;
            }
          });
        }

        const renderData = [];

        orbs.forEach((body, index) => {
          const data = orbDataMap.get(body.id);
          const baseRadius = body.circleRadius || BASE_RADIUS;
          let radius = baseRadius;
          let drawX = body.position.x;
          let drawY = body.position.y;
          let drawAngle = body.angle;
          let zDepth = 0;

          let ad = orbAnimData.get(body.id);
          if (!ad) {
            ad = { angle: Math.random() * Math.PI * 2, radius: 120 + Math.random() * 180, speed: 0.2 + Math.random() * 0.3 };
            orbAnimData.set(body.id, ad);
          }

          if (displayMode === 'cyclone') {
            const time = cycloneTime;
            const focalAngle = cycloneFocalAngle;
            if (ad.zLayer === undefined) {
              ad.zLayer = Math.random();
              ad.joinTime = time;
              ad.ellipseRatioY = 0.4 + Math.random() * 0.15;
              ad.phaseOffset = Math.random() * Math.PI * 2;
              ad.wobbleSpeed = 0.2 + Math.random() * 0.5;
              ad.wobbleAmount = 20 + Math.random() * 30;
              ad.driftX = (Math.random() - 0.5) * 0.1;
              ad.driftY = (Math.random() - 0.5) * 0.08;
              ad.tiltPhase = Math.random() * Math.PI * 2;
            }
            const zLayer = ad.zLayer;
            const timeSinceJoin = time - (ad.joinTime || 0);
            const catchUp = Math.min(1, timeSinceJoin / 3);
            const catchUpEase = 1 - Math.pow(1 - catchUp, 3);
            const depthSpeed = 0.15 + zLayer * 0.35;
            const screenSize = Math.min(w, h);
            const baseRX = (screenSize * 0.38) * (0.7 + zLayer * 0.5);
            const baseRY = baseRX * ad.ellipseRatioY;
            const angle = ad.angle + time * depthSpeed;
            const wi = 0.6 + zLayer * 0.6;
            const w1 = Math.sin(time * ad.wobbleSpeed + ad.phaseOffset) * ad.wobbleAmount * wi;
            const w2 = Math.sin(time * 0.3 + index * 0.5) * 15 * wi;
            const w3 = Math.cos(time * 0.15 + ad.phaseOffset * 2) * 12 * wi;
            const w4 = Math.sin(time * 0.1 + index) * 10 * wi;
            const breathe = Math.sin(time * 0.12 + index * 0.15) * 30 * wi;
            const rX = baseRX + w1 + breathe;
            const rY = baseRY + w2 * 0.4 + breathe * 0.3;
            const dOX = Math.sin(time * ad.driftX + ad.tiltPhase) * 30 * wi;
            const dOY = Math.cos(time * ad.driftY + ad.tiltPhase) * 20 * wi;
            const tX = centerX + Math.cos(angle) * rX + dOX + w3;
            const tY = centerY + Math.sin(angle) * rY + dOY + w4;
            const eX = centerX + (Math.random() - 0.5) * 100;
            const eY = -100;
            drawX = eX + (tX - eX) * catchUpEase;
            drawY = eY + (tY - eY) * catchUpEase;
            const angleFromFocal = Math.abs(Math.sin(angle - focalAngle));
            const focalBoost = 1 + angleFromFocal * 0.5 * zLayer;
            const depthScale = (0.4 + zLayer * 1.6) * focalBoost;
            radius = baseRadius * depthScale * catchUpEase;
            zDepth = zLayer;
            drawAngle = Math.sin(time * 0.2 + ad.phaseOffset) * 0.15;
            Matter.Body.setPosition(body, { x: drawX, y: drawY });
            Matter.Body.setStatic(body, true);
          } else if (displayMode === 'shapes') {
            if (ad.targetX !== undefined && ad.targetY !== undefined) {
              const dx = ad.targetX - body.position.x;
              const dy = ad.targetY - body.position.y;
              const nx = body.position.x + dx * 0.08;
              const ny = body.position.y + dy * 0.08;
              Matter.Body.setPosition(body, { x: nx, y: ny });
              Matter.Body.setStatic(body, true);
              drawX = nx;
              drawY = ny;
            }
          } else {
            Matter.Body.setStatic(body, false);
          }

          renderData.push({ body, data, drawX, drawY, drawAngle, radius, zDepth });
        });

        if (displayMode === 'cyclone') renderData.sort((a, b) => a.zDepth - b.zDepth);

        renderData.forEach(({ data, drawX, drawY, drawAngle, radius }) => {
          ctx.save();
          ctx.translate(drawX, drawY);
          ctx.rotate(drawAngle);
          ctx.save();
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
          ctx.closePath();
          ctx.clip();
          if (data?.image) {
            ctx.drawImage(data.image, -radius, -radius, radius * 2, radius * 2);
          } else {
            ctx.fillStyle = '#ddd';
            ctx.fill();
          }
          ctx.restore();
          if (overlayImage) {
            ctx.drawImage(overlayImage, -radius, -radius, radius * 2, radius * 2);
          }
          ctx.restore();
        });

        if (displayMode === 'physics') {
          Matter.Engine.update(engine, 1000 / 60);
        }

        animationId = requestAnimationFrame(render);
      }

      render();

      // Resize handler
      function handleResize() {
        const rect = getContainerRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.resetTransform();
        ctx.scale(dpr, dpr);
        const wallT = 50;
        Matter.Body.setPosition(walls[0], { x: rect.width / 2, y: rect.height + wallT / 2 });
        Matter.Body.setPosition(walls[1], { x: -wallT / 2, y: rect.height / 2 });
        Matter.Body.setPosition(walls[2], { x: rect.width + wallT / 2, y: rect.height / 2 });
      }

      window.addEventListener('resize', handleResize);

      // Button handlers
      btnDrop.addEventListener('click', (e) => { e.stopPropagation(); addOrb(); });
      btnPhysics.addEventListener('click', (e) => { e.stopPropagation(); setMode('physics'); });
      btnCyclone.addEventListener('click', (e) => { e.stopPropagation(); setMode('cyclone'); });
      btnShapes.addEventListener('click', (e) => { e.stopPropagation(); setMode('shapes'); });
      btnMoon.addEventListener('click', (e) => { e.stopPropagation(); toggleMoon(); });
      btnClear.addEventListener('click', (e) => { e.stopPropagation(); clearOrbs(); });
    }

    // Start when in viewport (lazy init)
    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        observer.disconnect();
        init();
      }
    }, { threshold: 0.1 });
    observer.observe(container);
  })();
  </script>
</body>
</html>
