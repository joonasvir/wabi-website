<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wabi — The first personal software platform</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js" defer></script>
  <style>
    @font-face { font-family: 'Selecta'; src: url('/fonts/Selecta-Regular.otf') format('opentype'); font-weight: 400; font-style: normal; font-display: swap; }
    @font-face { font-family: 'Selecta'; src: url('/fonts/Selecta-Medium.otf') format('opentype'); font-weight: 500; font-style: normal; font-display: swap; }
    @font-face { font-family: 'Selecta'; src: url('/fonts/Selecta-Bold.otf') format('opentype'); font-weight: 700; font-style: normal; font-display: swap; }
    @font-face { font-family: 'Kalice'; src: url('/fonts/Kalice-Trial-Regular.woff2') format('woff2'); font-weight: 400; font-style: normal; font-display: swap; }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Selecta', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      color: #191919;
      background: #111;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* ===== NAV ===== */
    nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 24px 24px;
      position: fixed;
      top: 0; left: 0; right: 0;
      z-index: 100;
    }
    @media (min-width: 768px) { nav { padding: 32px 32px; } }

    .nav-logo { display: flex; align-items: center; text-decoration: none; }

    /* Wabi glyph: 5 circles in quincunx */
    .wabi-glyph { position: relative; width: 38px; height: 24px; opacity: 0.3; }
    .wabi-glyph .dot { position: absolute; border-radius: 50%; background: #191919; width: 12px; height: 12px; }
    .wabi-glyph .dot:nth-child(1) { top: 0; left: 1px; }
    .wabi-glyph .dot:nth-child(2) { top: 0; left: 13px; }
    .wabi-glyph .dot:nth-child(3) { top: 0; left: 25px; }
    .wabi-glyph .dot:nth-child(4) { top: 12px; left: 7px; }
    .wabi-glyph .dot:nth-child(5) { top: 12px; left: 19px; }
    @media (min-width: 768px) {
      .wabi-glyph { width: 54px; height: 34px; }
      .wabi-glyph .dot { width: 17px; height: 17px; }
      .wabi-glyph .dot:nth-child(1) { top: 0; left: 1px; }
      .wabi-glyph .dot:nth-child(2) { top: 0; left: 18px; }
      .wabi-glyph .dot:nth-child(3) { top: 0; left: 36px; }
      .wabi-glyph .dot:nth-child(4) { top: 15px; left: 10px; }
      .wabi-glyph .dot:nth-child(5) { top: 15px; left: 27px; }
    }

    .nav-right { display: flex; align-items: center; gap: 36px; }

    .nav-link {
      color: #525252;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: -0.16px;
      transition: color 0.2s;
    }
    .nav-link:hover { color: #191919; }
    @media (min-width: 768px) { .nav-link { font-size: 16px; } }

    /* ===== GLASSMORPHIC BUTTON ===== */
    @property --angle-1 { syntax: '<angle>'; inherits: false; initial-value: -75deg; }
    @property --angle-2 { syntax: '<angle>'; inherits: false; initial-value: -45deg; }

    .glass-btn-wrap {
      position: relative; z-index: 2; border-radius: 999vw;
      background: transparent; pointer-events: none;
      transition: all 400ms cubic-bezier(0.25, 1, 0.5, 1);
    }
    .glass-btn-shadow {
      position: absolute;
      width: calc(100% + 2em); height: calc(100% + 2em);
      top: calc(0% - 1em); left: calc(0% - 1em);
      filter: blur(clamp(2px, 0.125em, 12px));
      overflow: visible; pointer-events: none;
    }
    .glass-btn-shadow::after {
      content: ''; position: absolute; z-index: 0; inset: 0; border-radius: 999vw;
      background: linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0.1));
      width: calc(100% - 2em - 0.25em); height: calc(100% - 2em - 0.25em);
      top: calc(2em - 0.5em); left: calc(2em - 0.875em);
      padding: 0.125em; box-sizing: border-box;
      mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0); mask-composite: exclude;
      transition: all 400ms cubic-bezier(0.25, 1, 0.5, 1); opacity: 1;
    }
    .glass-btn {
      all: unset; cursor: pointer; position: relative;
      -webkit-tap-highlight-color: rgba(0,0,0,0); pointer-events: auto; z-index: 3;
      background: linear-gradient(-75deg, rgba(255,255,255,0.05), rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      border-radius: 999vw;
      box-shadow:
        inset 0 0.125em 0.125em rgba(0,0,0,0.05),
        inset 0 -0.125em 0.125em rgba(255,255,255,0.5),
        0 0.25em 0.125em -0.125em rgba(0,0,0,0.2),
        0 0 0.1em 0.25em inset rgba(255,255,255,0.2),
        0 0 0 0 rgba(255,255,255,1);
      backdrop-filter: blur(clamp(1px, 0.125em, 4px));
      transition: all 400ms cubic-bezier(0.25, 1, 0.5, 1);
      display: flex; align-items: center; justify-content: center;
      height: 46px;
    }
    .glass-btn:hover {
      transform: scale(0.975);
      box-shadow:
        inset 0 0.125em 0.125em rgba(0,0,0,0.05),
        inset 0 -0.125em 0.125em rgba(255,255,255,0.5),
        0 0.15em 0.05em -0.1em rgba(0,0,0,0.25),
        0 0 0.05em 0.1em inset rgba(255,255,255,0.5),
        0 0 0 0 rgba(255,255,255,1);
    }
    .glass-btn span {
      position: relative; width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      user-select: none; color: rgba(50,50,50,1);
      text-shadow: 0em 0.05em 0.05em rgba(0,0,0,0.05);
      transition: all 400ms cubic-bezier(0.25, 1, 0.5, 1);
      padding-inline: 1.75em; font-size: 16px; font-weight: 500;
      letter-spacing: -0.18px; white-space: nowrap;
    }
    /* Shine */
    .glass-btn span::after {
      content: ''; display: block; position: absolute; z-index: 3;
      width: calc(100% - clamp(1px,0.0625em,4px)); height: calc(100% - clamp(1px,0.0625em,4px));
      top: calc(0% + clamp(1px,0.0625em,4px)/2); left: calc(0% + clamp(1px,0.0625em,4px)/2);
      border-radius: 999vw; overflow: clip;
      background: linear-gradient(var(--angle-2), rgba(255,255,255,0) 0%, rgba(255,255,255,0.5) 40% 50%, rgba(255,255,255,0) 55%);
      mix-blend-mode: screen; pointer-events: none;
      background-size: 200% 200%; background-position: 0% 50%; background-repeat: no-repeat;
      transition: background-position 500ms cubic-bezier(0.25,1,0.5,1), --angle-2 500ms cubic-bezier(0.25,1,0.5,1);
    }
    .glass-btn:hover span::after { background-position: 25% 50%; }
    /* Outline */
    .glass-btn::after {
      content: ''; position: absolute; z-index: 1; inset: 0; border-radius: 999vw;
      width: calc(100% + clamp(1px,0.0625em,4px)); height: calc(100% + clamp(1px,0.0625em,4px));
      top: calc(0% - clamp(1px,0.0625em,4px)/2); left: calc(0% - clamp(1px,0.0625em,4px)/2);
      padding: clamp(1px,0.0625em,4px); box-sizing: border-box;
      background:
        conic-gradient(from var(--angle-1) at 50% 50%, rgba(0,0,0,0.5), rgba(0,0,0,0) 5% 40%, rgba(0,0,0,0.5) 50%, rgba(0,0,0,0) 60% 95%, rgba(0,0,0,0.5)),
        linear-gradient(180deg, rgba(255,255,255,0.5), rgba(255,255,255,0.5));
      mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0); mask-composite: exclude;
      transition: all 400ms cubic-bezier(0.25,1,0.5,1), --angle-1 500ms ease;
      box-shadow: inset 0 0 0 calc(clamp(1px,0.0625em,4px)/2) rgba(255,255,255,0.5);
    }
    .glass-btn:hover::after { --angle-1: -125deg; }
    .glass-btn-wrap:has(button:hover) .glass-btn-shadow { filter: blur(clamp(2px,0.0625em,6px)); }
    .glass-btn-wrap:has(button:active) { transform: rotate3d(1,0,0,25deg); }

    /* Nav header variant */
    .glass-btn-wrap--header { width: 126px; }
    .glass-btn-wrap--header .glass-btn { width: 126px; height: 40px; }
    .glass-btn-wrap--header .glass-btn span { font-size: 14px; font-weight: 400; letter-spacing: -0.16px; color: #363636; }
    @media (min-width: 768px) {
      .glass-btn-wrap--header { width: 145px; }
      .glass-btn-wrap--header .glass-btn { width: 145px; height: 46px; }
      .glass-btn-wrap--header .glass-btn span { font-size: 16px; }
    }

    /* Large CTA variant */
    .glass-btn-wrap--cta { width: 280px; }
    .glass-btn-wrap--cta .glass-btn { width: 280px; height: 68px; }
    .glass-btn-wrap--cta .glass-btn span { font-size: 18px; font-weight: 500; }
    @media (min-width: 768px) {
      .glass-btn-wrap--cta { width: 200px; }
      .glass-btn-wrap--cta .glass-btn { width: 200px; }
    }

    /* ===== SECTIONS ===== */
    section { padding: 120px 24px; text-align: center; }

    .section-badge {
      display: inline-flex; align-items: center; padding: 6px 16px; height: 32px;
      border-radius: 999vw; margin-bottom: 20px;
      font-size: 13px; font-weight: 500; color: #525252;
      background: linear-gradient(-75deg, rgba(255,255,255,0.05), rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      backdrop-filter: blur(2px);
      box-shadow:
        inset 0 1px 1px rgba(0,0,0,0.05),
        inset 0 -1px 1px rgba(255,255,255,0.5),
        0 2px 1px -1px rgba(0,0,0,0.15);
      position: relative;
    }
    .section-badge::after {
      content: ''; position: absolute; inset: 0; border-radius: 999vw;
      padding: 1px; box-sizing: border-box;
      background: conic-gradient(from -75deg at 50% 50%, rgba(0,0,0,0.3), rgba(0,0,0,0) 5% 40%, rgba(0,0,0,0.3) 50%, rgba(0,0,0,0) 60% 95%, rgba(0,0,0,0.3)),
        linear-gradient(180deg, rgba(255,255,255,0.5), rgba(255,255,255,0.5));
      mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0); mask-composite: exclude;
    }

    .section-heading {
      font-size: 58px; font-weight: 400; line-height: 64px;
      margin-bottom: 20px; letter-spacing: -0.03em;
    }

    .section-sub {
      font-size: 25px; color: #525252; max-width: 580px;
      margin: 0 auto; line-height: 34px; letter-spacing: -0.03em;
    }

    /* ===== HERO ===== */
    .hero { padding: 120px 24px 80px; }

    .hero-heading {
      font-size: 28px; font-weight: 500; line-height: 34px;
      letter-spacing: -0.02em; max-width: 520px; margin: 0 auto 48px;
    }

    .hero-form {
      display: flex; flex-direction: column; align-items: center; gap: 12px;
    }

    .hero-input-wrap {
      width: 280px; height: 68px; position: relative;
      border: 1px solid rgba(255,255,255,0.6); border-radius: 999px;
      background: rgba(255,255,255,0.25);
      box-shadow:
        0px 1px 0px rgba(119,119,119,0.15), inset 0 8px 6px rgba(0,0,0,0.04),
        -1px 1px 0px rgba(0,0,0,0), 0 50px 20px rgba(0,0,0,0.01), 0px 0px 0px rgba(0,0,0,0.04),
        1px 1px 11px rgba(0,0,0,0.07), 0 3px 7px rgba(0,0,0,0.08);
    }

    .hero-input-wrap input {
      width: 100%; height: 100%; border: none; outline: none;
      background: transparent; border-radius: 999px;
      padding: 0 24px; font-family: inherit;
      font-size: 18px; color: #191919; letter-spacing: -0.18px;
    }
    .hero-input-wrap input::placeholder { color: rgba(0,0,0,0.5); }

    @media (min-width: 768px) {
      .hero-heading { font-size: 28px; }
      .hero-form { flex-direction: row; justify-content: center; gap: 12px; }
    }

    /* ===== HERO ORB SCROLL ===== */
    .hero-orb-scroll { position: relative; height: 105vh; }
    .hero-orb-sticky {
      position: sticky; top: 0; height: 100vh;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
    }
    .hero-content-1, .hero-content-2 {
      position: absolute; width: 100%; text-align: center;
      padding: 0 24px; will-change: opacity, transform;
    }
    .hero-content-1 { top: calc(28% + 180px); transform: translateY(-50%); z-index: 7; }
    .hero-content-2 { top: calc(42% + 80px); transform: translateY(0); opacity: 0; }
    #orbGlassOverlay {
      position: absolute; z-index: 5; pointer-events: none;
      mix-blend-mode: screen;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      will-change: transform, width, height;
      opacity: 0;
    }
    .hero-landing-orb {
      position: absolute; z-index: 6;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: none; border: none; box-shadow: none;
      display: flex; align-items: center; justify-content: center;
      pointer-events: none; opacity: 0;
    }
    .hero-landing-orb svg { width: 32px; height: 32px; color: #666; stroke-width: 2; }
    .hero-landing-orb.clickable { pointer-events: auto; cursor: pointer; }
    .orb-bubble {
      position: absolute; z-index: 5; border-radius: 50%; pointer-events: none;
      background-size: cover; background-position: center;
      will-change: transform, opacity;
    }
    .hero-content-1 .section-heading {
      margin-bottom: 36px; font-family: 'Kalice', serif;
      font-size: 75px; line-height: 84px; letter-spacing: -0.01em;
      color: #fff;
      opacity: 0; animation: heroFadeIn 1.2s ease-out 0.2s forwards;
    }
    @keyframes heroFadeIn {
      0% { opacity: 0; filter: blur(8px); transform: translateY(12px); }
      100% { opacity: 1; filter: blur(0px); transform: translateY(0); }
    }
    .hero-content-1 .glass-btn-wrap {
      opacity: 0; animation: heroFadeIn 1.2s ease-out 0.4s forwards;
    }
    #glassOrbCanvas {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0; animation: orbFadeIn 1.4s ease-out 0.7s forwards;
    }
    @keyframes orbFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
      pointer-events: none; z-index: 5;
    }
    .meet-heading {
      font-family: 'Kalice', serif;
      font-size: 66px; font-weight: 400; line-height: 76px;
      letter-spacing: -0.03em; margin-bottom: 20px;
    }

    /* ===== CREATE CARDS ===== */
    .create-cards {
      position: relative; max-width: 900px; height: 700px;
      margin: 48px auto 0; cursor: grab; user-select: none;
      -webkit-user-select: none;
    }
    .create-cards:active { cursor: grabbing; }
    .create-card {
      position: absolute; border-radius: 32px; overflow: hidden;
      box-shadow: 0 8px 40px rgba(0,0,0,0.12);
      left: 50%; top: 50%;
      transition: transform 0.5s cubic-bezier(0.25,1,0.5,1),
                  opacity 0.5s cubic-bezier(0.25,1,0.5,1),
                  box-shadow 0.5s cubic-bezier(0.25,1,0.5,1);
      width: 473px; height: 642px;
    }
    .create-card video {
      display: block; width: 100%; height: 100%; object-fit: cover;
      pointer-events: none;
    }
    /* States: active (front), prev (left behind), next (right behind) */
    .create-card[data-pos="active"] {
      transform: translate(-50%, -50%) rotate(0deg) scale(1);
      z-index: 3; opacity: 1;
      box-shadow: 0 12px 48px rgba(0,0,0,0.15);
    }
    .create-card[data-pos="prev"] {
      transform: translate(calc(-50% - 50px), -50%) rotate(-5deg) scale(0.9);
      z-index: 1; opacity: 0.85;
    }
    .create-card[data-pos="next"] {
      transform: translate(calc(-50% + 50px), -50%) rotate(5deg) scale(0.9);
      z-index: 2; opacity: 0.85;
    }
    .create-dots {
      display: flex; justify-content: center; gap: 8px;
      margin-top: 20px;
    }
    .create-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: #d4d4d4; border: none; padding: 0; cursor: pointer;
      transition: background 0.3s, transform 0.3s;
    }
    .create-dot.active { background: #191919; transform: scale(1.2); }
    @media (max-width: 640px) {
      .create-cards { height: 520px; }
      .create-card { width: 364px; height: 494px; }
      .create-card[data-pos="prev"] { transform: translate(calc(-50% - 35px), -50%) rotate(-5deg) scale(0.88); }
      .create-card[data-pos="next"] { transform: translate(calc(-50% + 35px), -50%) rotate(5deg) scale(0.88); }
    }

    /* ===== CATEGORY PILLS ===== */
    .category-pills { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; margin-top: 32px; }
    .pill {
      display: inline-flex; align-items: center; gap: 8px; padding: 14px 28px;
      border-radius: 999vw; font-size: 17px; font-weight: 500;
      border: none; color: #525252; cursor: pointer; transition: all 0.3s;
      position: relative;
      background: linear-gradient(-75deg, rgba(255,255,255,0.05), rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      backdrop-filter: blur(2px);
      box-shadow:
        inset 0 1px 1px rgba(0,0,0,0.05),
        inset 0 -1px 1px rgba(255,255,255,0.5),
        0 2px 1px -1px rgba(0,0,0,0.12);
    }
    .pill::after {
      content: ''; position: absolute; inset: 0; border-radius: 999vw;
      padding: 1px; box-sizing: border-box;
      background: conic-gradient(from -75deg at 50% 50%, rgba(0,0,0,0.25), rgba(0,0,0,0) 5% 40%, rgba(0,0,0,0.25) 50%, rgba(0,0,0,0) 60% 95%, rgba(0,0,0,0.25)),
        linear-gradient(180deg, rgba(255,255,255,0.5), rgba(255,255,255,0.5));
      mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0); mask-composite: exclude;
      pointer-events: none;
    }
    .pill:hover { transform: scale(0.97); box-shadow: inset 0 1px 1px rgba(0,0,0,0.05), inset 0 -1px 1px rgba(255,255,255,0.5), 0 1px 1px -1px rgba(0,0,0,0.15); }
    .pill.active { background: #191919; color: #f0f0f0; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .pill.active::after { display: none; }
    .pill-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; }
    @media (max-width: 640px) {
      .pill { padding: 10px 20px; font-size: 14px; }
    }

    /* ===== INTEGRATIONS ===== */
    .integrations-text { font-size: 35px; font-weight: 400; letter-spacing: -0.03em; line-height: 42px; }

    /* ===== CTA ===== */
    .cta-section { padding: 100px 24px; }
    .cta-heading {
      font-size: 58px; font-weight: 400; line-height: 64px;
      letter-spacing: -0.03em; max-width: 580px; margin: 0 auto 20px;
    }

    /* ===== FOOTER ===== */
    footer {
      display: flex; align-items: center; justify-content: space-between;
      padding: 24px 32px; border-top: 1px solid #ddd; font-size: 12px; color: #737373;
    }
    .footer-logo { display: flex; align-items: center; gap: 8px; text-decoration: none; }
    .footer-wordmark { font-size: 14px; font-weight: 500; color: #191919; opacity: 0.3; letter-spacing: -0.02em; }
    .footer-glyph { position: relative; width: 29px; height: 18px; opacity: 0.3; }
    .footer-glyph .dot { position: absolute; border-radius: 50%; background: #191919; width: 9px; height: 9px; }
    .footer-glyph .dot:nth-child(1) { top: 0; left: 1px; }
    .footer-glyph .dot:nth-child(2) { top: 0; left: 10px; }
    .footer-glyph .dot:nth-child(3) { top: 0; left: 19px; }
    .footer-glyph .dot:nth-child(4) { top: 8px; left: 5px; }
    .footer-glyph .dot:nth-child(5) { top: 8px; left: 15px; }
    .footer-links { display: flex; gap: 24px; }
    .footer-links a { color: #737373; text-decoration: none; font-size: 12px; }
    .footer-links a:hover { color: #191919; }

    /* ===== DISCOVER GALLERY ===== */
    .discover-gallery {
      position: relative; width: 100vw; height: 50vh; min-height: 360px;
      margin: 48px calc(-50vw + 50%) 0;
      perspective: 1200px; overflow: visible;
      cursor: grab; display: flex; align-items: center; justify-content: center;
    }
    .discover-gallery:active { cursor: grabbing; }
    .discover-strip {
      position: relative; width: 100%; height: 100%;
      transform-style: preserve-3d; will-change: transform;
    }
    .discover-card {
      position: absolute; top: 50%; left: 50%;
      width: 220px; height: 240px;
      margin-left: -110px; margin-top: -120px;
      border-radius: 20px; overflow: hidden;
      transform-style: preserve-3d; will-change: transform, opacity;
      background: rgba(255,255,255,0.85);
      box-shadow: 0 2px 16px rgba(0,0,0,0.06),
        inset 0 1px 0 rgba(255,255,255,0.9),
        inset 0 -1px 2px rgba(0,0,0,0.04);
      display: flex; flex-direction: column; align-items: center;
      justify-content: center; gap: 12px; padding: 20px 20px 18px;
    }
    .discover-card:hover {
      box-shadow: 0 8px 32px rgba(0,0,0,0.1),
        inset 0 1px 0 rgba(255,255,255,0.9),
        inset 0 -1px 2px rgba(0,0,0,0.04);
    }
    .discover-orb {
      width: 160px; height: 160px; border-radius: 50%;
      position: relative; overflow: hidden; flex-shrink: 0;
      margin: 0 auto;
    }
    .discover-orb img {
      width: 100%; height: 100%; object-fit: cover; display: block;
      position: absolute; top: 0; left: 0;
    }
    .discover-orb .orb-glass {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 1;
    }
    .discover-card-name {
      font-size: 16px; font-weight: 500; color: #7a3b2e;
      letter-spacing: -0.02em; text-align: center;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      width: 100%;
    }

    /* ===== ORB PROPERTIES PANEL ===== */
    .orb-panel {
      position: fixed; top: 25%; right: 24px; bottom: 25%;
      z-index: 90; width: 300px;
      background: rgba(255,255,255,0.92); backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 20px; padding: 24px;
      display: flex; flex-direction: column;
      box-shadow: 0 4px 30px rgba(0,0,0,0.08), 0 0 0 1px rgba(0,0,0,0.04);
      font-family: inherit; transition: transform 0.4s cubic-bezier(0.25,1,0.5,1), opacity 0.4s;
    }
    .orb-panel.collapsed { transform: translateX(calc(100% + 24px)); }
    .orb-panel-header {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 20px; flex-shrink: 0;
    }
    .orb-panel-body {
      overflow-y: auto; flex: 1; min-height: 0;
    }
    .orb-panel-title { font-size: 18px; font-weight: 500; letter-spacing: -0.02em; }
    .orb-panel-toggle {
      width: 36px; height: 36px; border-radius: 50%; border: 1px solid #ddd;
      background: white; cursor: pointer; display: flex;
      align-items: center; justify-content: center; transition: transform 0.3s;
    }
    .orb-panel.collapsed .orb-panel-toggle { transform: rotate(180deg); }
    .orb-panel-toggle svg { width: 16px; height: 16px; color: #525252; }
    .orb-prop { margin-bottom: 18px; }
    .orb-prop-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .orb-prop-label { font-size: 14px; font-weight: 400; color: #191919; }
    .orb-prop-value {
      font-size: 13px; font-weight: 500; color: #525252;
      background: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 6px;
      padding: 2px 8px; font-family: 'SF Mono', monospace; min-width: 48px; text-align: center;
    }
    .orb-prop input[type="range"] {
      width: 100%; height: 4px; -webkit-appearance: none; appearance: none;
      background: #e5e5e5; border-radius: 2px; outline: none;
    }
    .orb-prop input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%;
      background: #191919; cursor: pointer; border: 2px solid white;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }
    .orb-panel-buttons { display: flex; gap: 8px; margin-top: 20px; }
    .orb-panel-btn {
      flex: 1; padding: 10px 12px; border-radius: 10px; border: 1px solid #ddd;
      background: white; font-family: inherit; font-size: 13px; font-weight: 500;
      cursor: pointer; transition: background 0.2s;
    }
    .orb-panel-btn:hover { background: #f5f5f5; }
    @media (max-width: 768px) {
      .orb-panel { right: 12px; width: 260px; padding: 18px; }
    }

    /* ===== ORB FOOTER SECTION ===== */
    .orb-footer-section {
      position: relative; width: 100%; min-height: 100vh; overflow: hidden;
      background: #111;
    }
    .orb-footer-section canvas {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      touch-action: pan-y;
    }
    .orb-footer-section .cta-section {
      position: relative; z-index: 2;
    }
    .orb-footer-section .cta-heading { color: #f0f0f0; }
    .orb-footer-section .section-sub { color: rgba(255,255,255,0.5); }
    .orb-footer-section .hero-input-wrap {
      border-color: rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.08);
    }
    .orb-footer-section .hero-input-wrap input { color: #f0f0f0; }
    .orb-footer-section .hero-input-wrap input::placeholder { color: rgba(255,255,255,0.35); }
    .orb-footer-section footer {
      position: relative; z-index: 2; border-top-color: rgba(255,255,255,0.1);
    }
    .orb-footer-section .footer-glyph .dot { background: #f0f0f0; }
    .orb-footer-section .footer-wordmark { color: #f0f0f0; }
    .orb-footer-section .footer-links a { color: rgba(255,255,255,0.4); }
    .orb-footer-section .footer-links a:hover { color: #f0f0f0; }
    @media (max-width: 640px) {
      .section-heading { font-size: 32px; line-height: 38px; }
      .hero-content-1 .section-heading { font-size: 42px; line-height: 50px; }
      .section-sub { font-size: 18px; line-height: 26px; }
      .cta-heading { font-size: 32px; line-height: 38px; }
      .meet-heading { font-size: 39px; line-height: 47px; }
      .integrations-text { font-size: 24px; line-height: 30px; }
      nav { padding: 16px 20px; }
      footer { flex-direction: column; gap: 16px; }
    }
  </style>
</head>
<body>

  <!-- Nav -->
  <nav>
    <a href="/" class="nav-logo">
      <div class="wabi-glyph">
        <div class="dot"></div><div class="dot"></div><div class="dot"></div>
        <div class="dot"></div><div class="dot"></div>
      </div>
    </a>
    <div class="nav-right">
      <a href="/manifesto" class="nav-link">Read our manifesto</a>
      <div class="glass-btn-wrap glass-btn-wrap--header">
        <button class="glass-btn"><span>Get the app</span></button>
        <div class="glass-btn-shadow"></div>
      </div>
    </div>
  </nav>

  <!-- Hero with Glass Orb Scroll Animation -->
  <div class="hero-orb-scroll" id="heroOrbScroll">
    <div class="hero-orb-sticky" id="heroOrbSticky">
      <div class="hero-content-1" id="heroContent1">
        <h1 class="section-heading">A new era of software is here.</h1>
        <div style="display:flex;justify-content:center;margin-top:32px;">
          <div class="glass-btn-wrap glass-btn-wrap--cta">
            <button class="glass-btn"><span>Get started</span></button>
            <div class="glass-btn-shadow"></div>
          </div>
        </div>
      </div>
      <div class="hero-content-2" id="heroContent2">
        <h2 class="meet-heading"><span id="meetWabiText">Meet Wabi.</span><br><span id="meetSubHeading" style="opacity:0">The first personal software platform.</span></h2>
        <p class="section-sub" id="meetSubText" style="opacity:0">Create, discover, and remix any mini-app in minutes</p>
      </div>
      <canvas id="glassOrbCanvas"></canvas>
      <img id="orbGlassOverlay" src="/orb-glass-overlay.png" alt="" />
      <div class="hero-landing-orb" id="heroLandingOrb">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
          <line x1="12" y1="6" x2="12" y2="18"/><line x1="6" y1="12" x2="18" y2="12"/>
        </svg>
      </div>
    </div>
  </div>

  <script src="/liquid-glass.js"></script>
  <script>
  (function() {
    const scrollContainer = document.getElementById('heroOrbScroll');
    const canvas = document.getElementById('glassOrbCanvas');
    const content1 = document.getElementById('heroContent1');
    const content2 = document.getElementById('heroContent2');
    const landingOrb = document.getElementById('heroLandingOrb');
    const orbOverlay = document.getElementById('orbGlassOverlay');

    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;

    const glass = new LiquidGlass(canvas);
    window._liquidGlass = glass;

    // Off-screen canvas to rasterize HTML content behind the glass
    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = canvas.width;
    bgCanvas.height = canvas.height;
    const bgCtx = bgCanvas.getContext('2d');

    let progress = 0, targetProgress = 0;
    // Orb load-in animation: rises 40px over ~1.2s
    const orbLoadStart = performance.now();
    const orbLoadDuration = 1400;
    const orbLoadDelay = 700;

    function smoothstep(edge0, edge1, x) {
      const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
      return t * t * (3 - 2 * t);
    }

    function renderBgCanvas() {
      const w = bgCanvas.width / dpr;
      const h = bgCanvas.height / dpr;
      bgCtx.resetTransform();
      bgCtx.scale(dpr, dpr);
      // Background transitions from black to #f0f0f0 during scroll
      const bgVal = Math.round(17 + progress * (240 - 17));
      bgCtx.fillStyle = `rgb(${bgVal},${bgVal},${bgVal})`;
      bgCtx.fillRect(0, 0, w, h);

      // Blue line at very bottom edge — refraction pulls it into view
      bgCtx.save();
      bgCtx.globalAlpha = 0.01;
      bgCtx.fillStyle = '#4488ff';
      bgCtx.fillRect(0, h - 2, w, 2);
      bgCtx.restore();

      // "Meet Wabi." bg text: fade in + slide up from below (matches HTML content-2)
      const meetOpacity = smoothstep(0.25, 0.5, progress);
      const meetSlide = h * 0.8 * (1 - smoothstep(0.1, 1.0, progress));
      if (meetOpacity > 0.01) {
        bgCtx.save();
        bgCtx.globalAlpha = meetOpacity;
        bgCtx.textAlign = 'center';
        bgCtx.fillStyle = '#191919';
        const fontSize = w < 640 ? 39 : 66;
        bgCtx.font = `400 ${fontSize}px Kalice, Selecta, -apple-system, sans-serif`;
        bgCtx.fillText('Meet Wabi.', w / 2, h * 0.42 + 80 + meetSlide);
        bgCtx.restore();
      }

      // Rest of text: only at end of scroll (0.88-1.0)
      const restOpacity = smoothstep(0.55, 0.75, progress);
      if (restOpacity > 0.01) {
        const fontSize = w < 640 ? 39 : 66;
        const baseY = h * 0.42 + 80 + meetSlide;
        bgCtx.save();
        bgCtx.globalAlpha = restOpacity;
        bgCtx.textAlign = 'center';
        bgCtx.fillStyle = '#191919';
        bgCtx.font = `400 ${fontSize}px Kalice, Selecta, -apple-system, sans-serif`;
        bgCtx.fillText('The first personal software platform.', w / 2, baseY + fontSize * 1.15);
        bgCtx.fillStyle = '#525252';
        const subSize = w < 640 ? 18 : 25;
        bgCtx.font = `400 ${subSize}px Selecta, -apple-system, sans-serif`;
        bgCtx.fillText('Create, discover, and remix any mini-app in minutes', w / 2, baseY + fontSize * 1.15 + subSize * 2);
        bgCtx.restore();
      }
    }

    function animate() {
      const rect = scrollContainer.getBoundingClientRect();
      const totalScroll = scrollContainer.offsetHeight - window.innerHeight;
      targetProgress = Math.max(0, Math.min(1, -rect.top / totalScroll));
      progress += (targetProgress - progress) * 0.08;

      // Dark-to-light transition
      const bgVal = Math.round(17 + progress * (240 - 17));
      document.body.style.backgroundColor = `rgb(${bgVal},${bgVal},${bgVal})`;
      // Hero text: white → dark
      const textVal = Math.round(255 - progress * (255 - 25));
      content1.style.color = `rgb(${textVal},${textVal},${textVal})`;
      // Buttons and nav: white in dark mode, dark in light mode
      const btnVal = Math.round(255 - progress * (255 - 50));
      document.querySelectorAll('.glass-btn span').forEach(s => s.style.color = `rgb(${btnVal},${btnVal},${btnVal})`);
      document.querySelectorAll('.nav-link').forEach(l => l.style.color = `rgb(${btnVal},${btnVal},${btnVal})`);
      // Wabi glyph dots: white in dark, dark in light
      document.querySelectorAll('.wabi-glyph .dot').forEach(d => d.style.background = `rgb(${btnVal},${btnVal},${btnVal})`);
      // Button glass backgrounds: dimmer in dark mode, text stays fully bright
      const bgO = 0.5 + 0.5 * progress; // 0.5 at start → 1 at end
      document.querySelectorAll('.glass-btn').forEach(btn => {
        btn.style.background = `linear-gradient(-75deg, rgba(255,255,255,${0.05*bgO}), rgba(255,255,255,${0.2*bgO}), rgba(255,255,255,${0.05*bgO}))`;
        btn.style.boxShadow = `inset 0 0.125em 0.125em rgba(0,0,0,${0.05*bgO}), inset 0 -0.125em 0.125em rgba(255,255,255,${0.5*bgO}), 0 0.25em 0.125em -0.125em rgba(0,0,0,${0.2*bgO}), 0 0 0.1em 0.25em inset rgba(255,255,255,${0.2*bgO}), 0 0 0 0 rgba(255,255,255,1)`;
      });

      // Content-1: fade out + drift up simultaneously
      content1.style.opacity = 1 - smoothstep(0.0, 0.5, progress);
      const c1Drift = smoothstep(0, 0.5, progress) * 75;
      content1.style.transform = 'translateY(calc(-50% - ' + c1Drift + 'px))';

      // Content-2: starts from below viewport, same pace as content-1 but ends later
      // Content-1 rate: 150px over 0.5 progress = 300px/unit
      // Content-2: 500px over ~0.8 progress range ≈ same feel
      const c2Start = window.innerHeight * 0.8;
      const c2Slide = c2Start * (1 - smoothstep(0.1, 1.0, progress));
      content2.style.opacity = smoothstep(0.25, 0.5, progress);
      content2.style.transform = 'translateY(' + c2Slide + 'px)';
      // Sub-heading and subtitle only appear at end
      const restFade = smoothstep(0.55, 0.75, progress);
      document.getElementById('meetSubHeading').style.opacity = restFade;
      document.getElementById('meetSubText').style.opacity = restFade;


      // Render background content to off-screen canvas
      renderBgCanvas();
      glass.setBgFromCanvas(bgCanvas);

      // Smooth continuous animation — no discrete stages
      // posY: positive = up, negative = down
      const vh = window.innerHeight;

      // Position: linear rise throughout scroll
      const posEase = progress;
      const startY = -vh * 0.55 - 620;
      const endY = -vh * 0.22;
      // Orb load-in: rises 40px from below over 1.2s
      const loadElapsed = performance.now() - orbLoadStart - orbLoadDelay;
      const loadProgress = Math.max(0, Math.min(1, loadElapsed / orbLoadDuration));
      const loadEase = 1 - Math.pow(1 - loadProgress, 3);
      const loadOffset = -40 * (1 - loadEase);

      const posY = startY + (endY - startY) * posEase + 100 * Math.sin(progress * Math.PI) + loadOffset;

      // Size: shrinks faster / more linear
      const sizeEase = Math.pow(progress, 0.8);
      const diameter = 1750 - sizeEase * 1630; // 1750 -> 120

      // Always a perfect circle: equal width/height, radius=100%
      // Dynamic thickness: scales with orb size (100% of diameter)
      if (window._dynamicThickness !== false) {
        glass.settings.refThickness = diameter;
      }
      // Blur and refraction blur: start high, reach 0 by 60% scroll
      const blurFade = Math.max(0, 1 - progress / 0.6);
      glass.settings.blurRadius = Math.round(5 * blurFade);
      glass.settings.refBlur = 10 * blurFade;

      glass.setShapeSize(diameter, diameter);
      glass.setShapePosition(0, posY);

      // Render the glass effect
      glass.render();

      // Position landing orb overlay (+ icon proportional to orb)
      const landingOpacity = smoothstep(0.85, 0.95, progress);
      landingOrb.style.opacity = landingOpacity;
      landingOrb.style.left = '50%';
      const orbScreenY = window.innerHeight / 2 - posY;
      landingOrb.style.top = orbScreenY + 'px';
      landingOrb.style.width = diameter + 'px';
      landingOrb.style.height = diameter + 'px';
      // Scale icon proportionally to orb (40% of diameter, min 32px)
      const iconSize = Math.max(32, diameter * 0.4);
      const svg = landingOrb.querySelector('svg');
      svg.style.width = iconSize + 'px';
      svg.style.height = iconSize + 'px';

      // Position the PNG glass overlay to match the orb
      // Opacity: 10% at start, increases to 100% by end of scroll
      orbOverlay.style.opacity = (0.05 + 0.95 * smoothstep(0.6, 1.0, progress)) * loadEase;
      orbOverlay.style.left = '50%';
      orbOverlay.style.top = orbScreenY + 'px';
      orbOverlay.style.width = diameter + 'px';
      orbOverlay.style.height = diameter + 'px';

      // Make orb clickable when near final position
      if (progress > 0.9) {
        landingOrb.classList.add('clickable');
      } else {
        landingOrb.classList.remove('clickable');
      }

      // Store current orb info for bubble spawning
      window._orbInfo = { x: window.innerWidth / 2, y: orbScreenY, diameter: diameter };

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // Bubble spawning on orb click
    const BUBBLE_COLORS = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
      '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
      '#F8C471', '#82E0AA', '#F1948A', '#AED6F1', '#D7BDE2',
    ];
    const stickyEl = document.getElementById('heroOrbSticky');

    function spawnBubbles() {
      const info = window._orbInfo;
      if (!info) return;
      const count = 10 + Math.floor(Math.random() * 6);
      for (let i = 0; i < count; i++) {
        const bubble = document.createElement('div');
        bubble.className = 'orb-bubble';
        const size = 16 + Math.random() * 32;
        const color = BUBBLE_COLORS[Math.floor(Math.random() * BUBBLE_COLORS.length)];
        bubble.style.width = size + 'px';
        bubble.style.height = size + 'px';
        bubble.style.background = color;
        // Start at orb center with random offset within orb radius
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * info.diameter * 0.3;
        const startX = info.x + Math.cos(angle) * dist - size / 2;
        const startY = info.y + Math.sin(angle) * dist - size / 2;
        bubble.style.left = startX + 'px';
        bubble.style.top = startY + 'px';
        bubble.style.opacity = '0.9';
        stickyEl.appendChild(bubble);

        // Animate: float upward with drift
        const driftX = (Math.random() - 0.5) * 200;
        const riseY = -(150 + Math.random() * 250);
        const duration = 1200 + Math.random() * 800;
        const delay = Math.random() * 300;
        bubble.animate([
          { transform: 'translate(0, 0) scale(0.3)', opacity: 0 },
          { transform: 'translate(0, 0) scale(1)', opacity: 0.9, offset: 0.15 },
          { transform: `translate(${driftX}px, ${riseY}px) scale(0.6)`, opacity: 0 }
        ], {
          duration, delay, easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)', fill: 'forwards'
        }).onfinish = () => bubble.remove();
      }
    }

    landingOrb.addEventListener('click', spawnBubbles);

    window.addEventListener('resize', () => {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      glass.resize(canvas.width, canvas.height);
    });
  })();
  </script>

  <!-- Create -->
  <section>
    <span class="section-badge">Create</span>
    <h2 class="section-heading">Create anything</h2>
    <p class="section-sub">Go from idea to app in a snap. That thing you wished existed? Make it.</p>
    <div class="create-cards" id="createCards">
      <div class="create-card" data-pos="prev">
        <video muted loop playsinline preload="auto"><source src="/videos/create-onboarding-1.mp4" type="video/mp4"></video>
      </div>
      <div class="create-card" data-pos="active">
        <video autoplay muted loop playsinline><source src="/videos/create-onboarding-2.mp4" type="video/mp4"></video>
      </div>
      <div class="create-card" data-pos="next">
        <video muted loop playsinline preload="auto"><source src="/videos/create-onboarding-3.mp4" type="video/mp4"></video>
      </div>
    </div>
    <div class="create-dots" id="createDots">
      <button class="create-dot" data-idx="0"></button>
      <button class="create-dot active" data-idx="1"></button>
      <button class="create-dot" data-idx="2"></button>
    </div>
    <script>
    (function() {
      const container = document.getElementById('createCards');
      const cards = Array.from(container.querySelectorAll('.create-card'));
      const dots = Array.from(document.getElementById('createDots').querySelectorAll('.create-dot'));
      let active = 1;
      const positions = ['prev', 'active', 'next'];

      function update() {
        const prev = (active - 1 + cards.length) % cards.length;
        const next = (active + 1) % cards.length;
        cards.forEach((c, i) => {
          c.setAttribute('data-pos', 'next');
          const vid = c.querySelector('video');
          if (vid) { vid.pause(); vid.currentTime = 0; }
        });
        cards[prev].setAttribute('data-pos', 'prev');
        cards[active].setAttribute('data-pos', 'active');
        cards[next].setAttribute('data-pos', 'next');
        const activeVid = cards[active].querySelector('video');
        if (activeVid) activeVid.play();
        dots.forEach((d, i) => d.classList.toggle('active', i === active));
      }

      function goNext() { active = (active + 1) % cards.length; update(); }
      function goPrev() { active = (active - 1 + cards.length) % cards.length; update(); }
      function goTo(i) { active = i; update(); }

      // Dot clicks
      dots.forEach(d => d.addEventListener('click', () => goTo(parseInt(d.dataset.idx))));

      // Touch swipe
      let startX = 0, startY = 0, dragging = false, moved = false;
      container.addEventListener('touchstart', e => {
        startX = e.touches[0].clientX; startY = e.touches[0].clientY;
        dragging = true; moved = false;
      }, { passive: true });
      container.addEventListener('touchmove', e => {
        if (!dragging) return;
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        if (Math.abs(dx) > 20 && Math.abs(dx) > Math.abs(dy)) moved = true;
      }, { passive: true });
      container.addEventListener('touchend', e => {
        if (!dragging) return;
        dragging = false;
        const dx = e.changedTouches[0].clientX - startX;
        if (Math.abs(dx) > 40 && moved) { dx < 0 ? goNext() : goPrev(); }
      });

      // Mouse drag
      let mStartX = 0, mDragging = false, mMoved = false;
      container.addEventListener('mousedown', e => {
        mStartX = e.clientX; mDragging = true; mMoved = false;
        e.preventDefault();
      });
      window.addEventListener('mousemove', e => {
        if (!mDragging) return;
        if (Math.abs(e.clientX - mStartX) > 15) mMoved = true;
      });
      window.addEventListener('mouseup', e => {
        if (!mDragging) return;
        mDragging = false;
        const dx = e.clientX - mStartX;
        if (Math.abs(dx) > 40 && mMoved) { dx < 0 ? goNext() : goPrev(); }
      });
    })();
    </script>
  </section>

  <!-- Discover -->
  <section>
    <span class="section-badge">Discover</span>
    <h2 class="section-heading">Discover and remix</h2>
    <p class="section-sub">Explore thousands of free apps made by people like you</p>
    <div class="category-pills" id="categoryPills">
      <span class="pill active" data-category="essentials"><span class="pill-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10"/><path d="M2 12h20"/></svg></span>Essentials</span>
      <span class="pill" data-category="lifestyle"><span class="pill-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg></span>Lifestyle</span>
      <span class="pill" data-category="health"><span class="pill-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg></span>Health</span>
      <span class="pill" data-category="fitness"><span class="pill-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg></span>Fitness</span>
      <span class="pill" data-category="cooking"><span class="pill-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M12 2a10 10 0 0 1 0 20 10 10 0 0 1 0-20z"/></svg></span>Cooking</span>
      <span class="pill" data-category="tracking"><span class="pill-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg></span>Tracking</span>
    </div>
    <div class="discover-gallery" id="discoverGallery">
      <div class="discover-strip" id="discoverStrip"></div>
    </div>
  </section>

  <script>
  (function() {
    const gallery = document.getElementById('discoverGallery');
    const strip = document.getElementById('discoverStrip');
    const CARD_WIDTH = 240;
    const AUTO_SPEED = 0.3;

    const CATEGORY_NAMES = {
      essentials: ['Daily Art Tutor', 'Personal Reflection', 'Bucket List', 'Daily Mindfulness', 'Run Club', 'Ski Trip Planner', 'Recipe Book', 'Morning Routine', 'Travel Journal', 'Habit Tracker', 'Movie Watchlist', 'Plant Care', 'Budget Planner', 'Book Club', 'Workout Log'],
      lifestyle: ['Morning Pages', 'Gratitude Log', 'Capsule Wardrobe', 'Home Organizer', 'Gift Tracker', 'Mood Board', 'Vision Board', 'Dream Journal', 'Date Planner', 'Pet Care Log', 'Garden Planner', 'Minimalist Living', 'Slow Morning', 'Self Care Kit', 'Seasonal Goals'],
      health: ['Water Tracker', 'Sleep Logger', 'Med Reminder', 'Symptom Diary', 'Mental Check-in', 'Breathing Timer', 'Posture Check', 'Eye Rest Timer', 'Allergy Log', 'Blood Pressure', 'Step Counter', 'Vitamin Tracker', 'Stretch Routine', 'Migraine Diary', 'Skin Care Log'],
      fitness: ['Run Club', 'HIIT Timer', 'Yoga Flow', 'Gym Tracker', 'Cycling Log', 'Swimming Laps', 'Climbing Log', 'Body Weight', 'PR Tracker', 'Recovery Day', 'Mobility Flow', 'Jump Rope', 'Rowing Log', 'Trail Finder', 'Workout Split'],
      cooking: ['Recipe Book', 'Meal Planner', 'Grocery List', 'Sourdough Timer', 'Spice Guide', 'Wine Pairing', 'Fermentation Log', 'Baking Ratios', 'Smoothie Builder', 'Pantry Tracker', 'Soup Season', 'Knife Guide', 'Pasta Shapes', 'Coffee Brewing', 'Herb Garden'],
      tracking: ['Habit Tracker', 'Mood Logger', 'Time Blocks', 'Focus Timer', 'Reading Log', 'Savings Goal', 'Subscription Manager', 'Carbon Footprint', 'Screen Time', 'Learning Hours', 'Side Project', 'Networking Log', 'Idea Capture', 'Daily Score', 'Streak Counter'],
    };
    let currentCategory = 'essentials';
    const FALLBACK_COVERS = [
      'https://i.imgur.com/4Aq1p5V.png','https://i.imgur.com/qx8f4iH.png','https://i.imgur.com/AWPO3TG.png',
      'https://i.imgur.com/p9lsZOd.png','https://i.imgur.com/vwH7fhY.png','https://i.imgur.com/LMjFvVQ.png',
      'https://i.imgur.com/SfPZogI.png','https://i.imgur.com/4MhFEwN.png','https://i.imgur.com/cv5FCFY.png',
      'https://i.imgur.com/D5A4UUJ.png','https://i.imgur.com/PFsPgBN.png','https://i.imgur.com/B70veGi.png',
      'https://i.imgur.com/AehAw57.png','https://i.imgur.com/rwgRwAj.png','https://i.imgur.com/ojY9Fs3.png',
    ];

    let covers = [];
    let currentScroll = 0, targetScroll = 0, velocity = 0;
    let isDragging = false, lastX = 0;

    async function loadCovers() {
      try {
        const res = await fetch('https://api.wabi.ai/api/v1/app/random-covers?count=15');
        if (res.ok) {
          const json = await res.json();
          if (json.data?.covers?.length > 0) { covers = json.data.covers; return; }
        }
      } catch(e) {}
      covers = FALLBACK_COVERS;
    }

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function buildCards() {
      strip.innerHTML = '';
      const names = CATEGORY_NAMES[currentCategory];
      const shuffledCovers = shuffle(covers);
      shuffledCovers.forEach((url, i) => {
        const card = document.createElement('div');
        card.className = 'discover-card';
        card.dataset.index = i;

        const orb = document.createElement('div');
        orb.className = 'discover-orb';
        const img = document.createElement('img');
        img.src = url; img.loading = 'lazy'; img.draggable = false;
        orb.appendChild(img);
        const glass = document.createElement('img');
        glass.className = 'orb-glass';
        glass.src = '/orb-overlay.png'; glass.draggable = false;
        orb.appendChild(glass);
        card.appendChild(orb);

        const name = document.createElement('span');
        name.className = 'discover-card-name';
        name.textContent = names[i % names.length];
        card.appendChild(name);

        strip.appendChild(card);
      });
    }

    function startAnimation() {
      const cards = strip.querySelectorAll('.discover-card');
      const totalSetWidth = covers.length * CARD_WIDTH;

      function animate() {
        if (!isDragging) {
          targetScroll += velocity;
          velocity *= 0.95;
          targetScroll += AUTO_SPEED;
        }
        currentScroll += (targetScroll - currentScroll) * 0.1;

        cards.forEach(card => {
          const idx = parseInt(card.dataset.index);
          let vx = idx * CARD_WIDTH - currentScroll;
          while (vx < -totalSetWidth / 2) vx += totalSetWidth;
          while (vx > totalSetWidth / 2) vx -= totalSetWidth;

          if (Math.abs(vx) < window.innerWidth) {
            card.style.display = 'block';
            const progress = vx / (window.innerWidth / 1.5);
            const z = -Math.pow(Math.abs(progress), 2) * 400;
            const rotateY = progress * 35;
            card.style.transform = `translateX(${vx}px) translateZ(${z}px) rotateY(${rotateY}deg)`;
            card.style.opacity = 1 - Math.pow(Math.abs(progress), 3);
          } else {
            card.style.display = 'none';
          }
        });
        animFrame = requestAnimationFrame(animate);
      }
      animate();
    }

    let animFrame = null;

    async function init() {
      await loadCovers();
      buildCards();

      // Mouse drag
      gallery.addEventListener('mousedown', e => {
        isDragging = true; lastX = e.clientX; velocity = 0; e.preventDefault();
      });
      window.addEventListener('mouseup', () => { isDragging = false; });
      window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const delta = e.clientX - lastX; lastX = e.clientX;
        targetScroll -= delta * 1.5; velocity = -delta * 0.5;
      });

      // Touch drag
      gallery.addEventListener('touchstart', e => {
        isDragging = true; lastX = e.touches[0].clientX; velocity = 0;
      }, { passive: true });
      window.addEventListener('touchend', () => { isDragging = false; });
      window.addEventListener('touchmove', e => {
        if (!isDragging) return;
        const x = e.touches[0].clientX;
        const delta = x - lastX; lastX = x;
        targetScroll -= delta * 1.5; velocity = -delta * 0.5;
      }, { passive: true });

      startAnimation();

      // Category pill click handlers
      const pills = document.querySelectorAll('#categoryPills .pill');
      pills.forEach(pill => {
        pill.addEventListener('click', () => {
          const cat = pill.dataset.category;
          if (cat === currentCategory) return;
          currentCategory = cat;
          pills.forEach(p => p.classList.remove('active'));
          pill.classList.add('active');
          if (animFrame) cancelAnimationFrame(animFrame);
          buildCards();
          currentScroll = 0; targetScroll = 0; velocity = 0;
          startAnimation();
        });
      });
    }

    const observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) { observer.disconnect(); init(); }
    }, { threshold: 0.1 });
    observer.observe(gallery);
  })();
  </script>

  <!-- Remix -->
  <section>
    <span class="section-badge">Remix</span>
    <h2 class="section-heading">Remix everything</h2>
    <p class="section-sub">Take any app and make it yours</p>
  </section>

  <!-- Multiplayer -->
  <section>
    <span class="section-badge">Multiplayer</span>
    <h2 class="section-heading">Add your friends</h2>
    <p class="section-sub">Apps are better when they're shared. Invite your friends to your app. Wabi is social by design.</p>
  </section>

  <!-- Integrations -->
  <section>
    <p class="integrations-text">20+ integrations, and hundred to come</p>
  </section>

  <!-- Orb Properties Panel -->
  <div class="orb-panel" id="orbPanel">
    <div class="orb-panel-header">
      <span class="orb-panel-title">Orb Properties</span>
      <button class="orb-panel-toggle" id="orbPanelToggle">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="18 15 12 9 6 15"/></svg>
      </button>
    </div>
    <div class="orb-panel-body" id="orbPanelBody">
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Index of Refraction</span><span class="orb-prop-value" id="valIOR">3.00</span></div>
        <input type="range" min="1.0" max="500" step="0.01" value="3.0" data-uniform="refFactor" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header">
          <span class="orb-prop-label">Thickness</span>
          <span style="display:flex;align-items:center;gap:8px">
            <label style="font-size:11px;color:#888;cursor:pointer;display:flex;align-items:center;gap:4px">
              <input type="checkbox" id="dynamicThicknessToggle" checked style="margin:0" /> Dynamic
            </label>
            <span class="orb-prop-value" id="valThickness">2000</span>
          </span>
        </div>
        <input type="range" min="1" max="4000" step="1" value="2000" data-uniform="refThickness" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Dispersion</span><span class="orb-prop-value" id="valDispersion">1.60</span></div>
        <input type="range" min="0" max="30" step="0.1" value="1.6" data-uniform="refDispersion" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Refraction Blur</span><span class="orb-prop-value" id="valRefBlur">0.00</span></div>
        <input type="range" min="0" max="20" step="0.1" value="0" data-uniform="refBlur" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Fresnel Range</span><span class="orb-prop-value" id="valFresnelRange">48.10</span></div>
        <input type="range" min="1" max="100" step="0.1" value="48.1" data-uniform="refFresnelRange" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Fresnel Factor</span><span class="orb-prop-value" id="valFresnelFactor">38.65</span></div>
        <input type="range" min="0" max="100" step="0.1" value="38.65" data-uniform="refFresnelFactor" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Fresnel Hardness</span><span class="orb-prop-value" id="valFresnelHardness">28.51</span></div>
        <input type="range" min="0" max="100" step="0.1" value="28.51" data-uniform="refFresnelHardness" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Blur Radius</span><span class="orb-prop-value" id="valBlurRadius">1</span></div>
        <input type="range" min="0" max="100" step="1" value="1" data-uniform="blurRadius" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Shadow Factor</span><span class="orb-prop-value" id="valShadowFactor">5.00</span></div>
        <input type="range" min="0" max="100" step="0.1" value="5" data-uniform="shadowFactor" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Shadow Expand</span><span class="orb-prop-value" id="valShadowExpand">25.00</span></div>
        <input type="range" min="0" max="100" step="0.1" value="25" data-uniform="shadowExpand" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Glare Factor</span><span class="orb-prop-value" id="valGlareFactor">0.00</span></div>
        <input type="range" min="0" max="100" step="0.1" value="0" data-uniform="glareFactor" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Glare Range</span><span class="orb-prop-value" id="valGlareRange">54.18</span></div>
        <input type="range" min="0" max="100" step="0.1" value="54.18" data-uniform="glareRange" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Glare Angle</span><span class="orb-prop-value" id="valGlareAngle">-42.09</span></div>
        <input type="range" min="-180" max="180" step="0.1" value="-42.09" data-uniform="glareAngle" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Glare Hardness</span><span class="orb-prop-value" id="valGlareHardness">24.34</span></div>
        <input type="range" min="0" max="100" step="0.1" value="24.34" data-uniform="glareHardness" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Glare Convergence</span><span class="orb-prop-value" id="valGlareConvergence">56.36</span></div>
        <input type="range" min="0" max="100" step="0.1" value="56.36" data-uniform="glareConvergence" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Glare Opposite</span><span class="orb-prop-value" id="valGlareOppositeFactor">80.00</span></div>
        <input type="range" min="0" max="100" step="0.1" value="80" data-uniform="glareOppositeFactor" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Tint R</span><span class="orb-prop-value" id="valTintR">255</span></div>
        <input type="range" min="0" max="255" step="1" value="255" data-uniform="tintR" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Tint G</span><span class="orb-prop-value" id="valTintG">255</span></div>
        <input type="range" min="0" max="255" step="1" value="255" data-uniform="tintG" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Tint B</span><span class="orb-prop-value" id="valTintB">255</span></div>
        <input type="range" min="0" max="255" step="1" value="255" data-uniform="tintB" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Tint Opacity</span><span class="orb-prop-value" id="valTintA">0</span></div>
        <input type="range" min="0" max="255" step="1" value="0" data-uniform="tintA" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Shadow Pos X</span><span class="orb-prop-value" id="valShadowPosX">0.00</span></div>
        <input type="range" min="-50" max="50" step="0.1" value="0" data-uniform="shadowPosX" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Shadow Pos Y</span><span class="orb-prop-value" id="valShadowPosY">-10.00</span></div>
        <input type="range" min="-50" max="50" step="0.1" value="-10" data-uniform="shadowPosY" />
      </div>
      <div class="orb-prop">
        <div class="orb-prop-header"><span class="orb-prop-label">Merge Rate</span><span class="orb-prop-value" id="valMergeRate">0.05</span></div>
        <input type="range" min="0" max="1" step="0.01" value="0.05" data-uniform="mergeRate" />
      </div>
      <div class="orb-panel-buttons">
        <button class="orb-panel-btn" id="orbResetBtn">Reset to Default</button>
        <button class="orb-panel-btn" id="orbExtremeBtn">Extreme Settings</button>
      </div>
    </div>
  </div>
  <script>
  (function() {
    const panel = document.getElementById('orbPanel');
    const toggle = document.getElementById('orbPanelToggle');
    const defaults = { refFactor: 3.0, refThickness: 2000, refDispersion: 1.6, refBlur: 0, refFresnelRange: 48.1, refFresnelFactor: 38.65, refFresnelHardness: 28.51, blurRadius: 1, shadowFactor: 5, shadowExpand: 25, glareFactor: 0, glareRange: 54.18, glareAngle: -42.09, glareHardness: 24.34, glareConvergence: 56.36, glareOppositeFactor: 80, tintR: 255, tintG: 255, tintB: 255, tintA: 0, shadowPosX: 0, shadowPosY: -10, mergeRate: 0.05 };
    const extreme = { refFactor: 2.5, refThickness: 60, refDispersion: 25, refFresnelRange: 80, refFresnelFactor: 80, refFresnelHardness: 60, blurRadius: 20, shadowFactor: 50, shadowExpand: 50, glareFactor: 60, glareRange: 80, glareAngle: 0, glareHardness: 50, glareConvergence: 80, glareOppositeFactor: 100, tintR: 200, tintG: 220, tintB: 255, tintA: 40, shadowPosX: 0, shadowPosY: -20, mergeRate: 0.1 };

    toggle.addEventListener('click', () => panel.classList.toggle('collapsed'));

    // Show panel only when hero orb is in view
    const heroScroll = document.getElementById('heroOrbScroll');
    function checkVisibility() {
      const rect = heroScroll.getBoundingClientRect();
      const visible = rect.top < window.innerHeight && rect.bottom > 0;
      panel.style.opacity = visible ? '1' : '0';
      panel.style.pointerEvents = visible ? 'auto' : 'none';
    }
    window.addEventListener('scroll', checkVisibility, { passive: true });
    checkVisibility();

    const sliders = panel.querySelectorAll('input[type="range"]');
    const valueDisplays = {
      refFactor: document.getElementById('valIOR'),
      refThickness: document.getElementById('valThickness'),
      refDispersion: document.getElementById('valDispersion'),
      refBlur: document.getElementById('valRefBlur'),
      refFresnelRange: document.getElementById('valFresnelRange'),
      refFresnelFactor: document.getElementById('valFresnelFactor'),
      refFresnelHardness: document.getElementById('valFresnelHardness'),
      blurRadius: document.getElementById('valBlurRadius'),
      shadowFactor: document.getElementById('valShadowFactor'),
      shadowExpand: document.getElementById('valShadowExpand'),
      glareFactor: document.getElementById('valGlareFactor'),
      glareRange: document.getElementById('valGlareRange'),
      glareAngle: document.getElementById('valGlareAngle'),
      glareHardness: document.getElementById('valGlareHardness'),
      glareConvergence: document.getElementById('valGlareConvergence'),
      glareOppositeFactor: document.getElementById('valGlareOppositeFactor'),
      tintR: document.getElementById('valTintR'),
      tintG: document.getElementById('valTintG'),
      tintB: document.getElementById('valTintB'),
      tintA: document.getElementById('valTintA'),
      shadowPosX: document.getElementById('valShadowPosX'),
      shadowPosY: document.getElementById('valShadowPosY'),
      mergeRate: document.getElementById('valMergeRate'),
    };

    sliders.forEach(slider => {
      slider.addEventListener('input', () => {
        const key = slider.dataset.uniform;
        const val = parseFloat(slider.value);
        if (valueDisplays[key]) valueDisplays[key].textContent = val.toFixed(2);
        if (window._liquidGlass) {
          const s = window._liquidGlass.settings;
          if (key === 'tintR') s.tint.r = val;
          else if (key === 'tintG') s.tint.g = val;
          else if (key === 'tintB') s.tint.b = val;
          else if (key === 'tintA') s.tint.a = val;
          else if (key === 'shadowPosX') s.shadowPosition.x = val;
          else if (key === 'shadowPosY') s.shadowPosition.y = val;
          else s[key] = val;
        }
      });
    });

    function setValues(vals) {
      Object.entries(vals).forEach(([key, val]) => {
        const slider = panel.querySelector(`input[data-uniform="${key}"]`);
        if (slider) { slider.value = val; slider.dispatchEvent(new Event('input')); }
      });
    }

    document.getElementById('orbResetBtn').addEventListener('click', () => setValues(defaults));
    document.getElementById('orbExtremeBtn').addEventListener('click', () => setValues(extreme));

    // Dynamic thickness toggle
    window._dynamicThickness = true;
    const dynToggle = document.getElementById('dynamicThicknessToggle');
    const thicknessSlider = panel.querySelector('input[data-uniform="refThickness"]');
    dynToggle.addEventListener('change', () => {
      window._dynamicThickness = dynToggle.checked;
      thicknessSlider.disabled = dynToggle.checked;
    });
    thicknessSlider.disabled = true;
  })();
  </script>

  <!-- Orb Footer Section (CTA + Footer with orb background) -->
  <div class="orb-footer-section" id="orbSection">
    <canvas id="orbCanvas"></canvas>

    <section class="cta-section">
      <h2 class="cta-heading">Welcome to the era<br>of personal software</h2>
      <p class="section-sub" style="margin-bottom: 32px;">Where anyone can create, discover, remix, and share mini-apps — no code required.</p>
      <form class="hero-form" onsubmit="return false;">
        <div class="hero-input-wrap">
          <input type="email" placeholder="name@email.com" />
        </div>
        <div class="glass-btn-wrap glass-btn-wrap--cta">
          <button class="glass-btn" type="submit"><span>Join waitlist</span></button>
          <div class="glass-btn-shadow"></div>
        </div>
      </form>
    </section>

    <footer>
      <a href="/" class="footer-logo">
        <div class="footer-glyph">
          <div class="dot"></div><div class="dot"></div><div class="dot"></div>
          <div class="dot"></div><div class="dot"></div>
        </div>
        <span class="footer-wordmark">wabi</span>
      </a>
      <div class="footer-links">
        <a href="/manifesto">Read our manifesto</a>
        <a href="#">Privacy policy</a>
        <a href="#">Terms of service</a>
        <a href="#">Made by wabi</a>
      </div>
    </footer>
  </div>

  <script>
  (function() {
    const WABI_API_URL = 'https://api.wabi.ai/api/v1/app/random-covers?count=30';
    const FALLBACK_ORBS = [
      'https://i.imgur.com/4Aq1p5V.png','https://i.imgur.com/qx8f4iH.png','https://i.imgur.com/AWPO3TG.png',
      'https://i.imgur.com/p9lsZOd.png','https://i.imgur.com/vwH7fhY.png','https://i.imgur.com/LMjFvVQ.png',
      'https://i.imgur.com/SfPZogI.png','https://i.imgur.com/4MhFEwN.png','https://i.imgur.com/cv5FCFY.png',
      'https://i.imgur.com/D5A4UUJ.png','https://i.imgur.com/PFsPgBN.png','https://i.imgur.com/B70veGi.png',
      'https://i.imgur.com/AehAw57.png','https://i.imgur.com/rwgRwAj.png','https://i.imgur.com/ojY9Fs3.png',
      'https://i.imgur.com/SU1ihwl.png','https://i.imgur.com/ct0AeRD.png','https://i.imgur.com/0uZCyTe.png',
      'https://i.imgur.com/8dKpawM.png','https://i.imgur.com/EBMFd7A.png','https://i.imgur.com/34OFX6f.png',
      'https://i.imgur.com/nh6p2J0.png','https://i.imgur.com/9GEdegS.png','https://i.imgur.com/IUMWj6Y.png',
      'https://i.imgur.com/etdgUOx.png','https://i.imgur.com/6LgF0YR.png','https://i.imgur.com/7MqgR3i.png',
      'https://i.imgur.com/txHoBrO.png','https://i.imgur.com/iV88FY2.png','https://i.imgur.com/FAoVMHq.png',
    ];
    const BASE_RADIUS = 42;
    const MIN_SCALE = 0.9;
    const MAX_SCALE = 1.1;
    const DAMPING = 0.005;
    const DROP_COUNT = 30;
    const MOUSE_FORCE = 0.008;
    const MOUSE_RADIUS = 150;

    const container = document.getElementById('orbSection');
    const canvas = document.getElementById('orbCanvas');
    let engine, walls = [];
    let orbDataMap = new Map();
    let preloadedImages = new Map();
    let coverUrls = [];
    let overlayImage = null;
    let mousePos = { x: -9999, y: -9999 };

    function getRect() { return container.getBoundingClientRect(); }

    async function fetchCovers() {
      try {
        const res = await fetch(WABI_API_URL);
        if (!res.ok) throw new Error();
        const json = await res.json();
        const urls = json.data?.covers || [];
        if (urls.length > 0) return urls;
      } catch(e) {}
      return [];
    }

    async function preloadImages() {
      const urls = await fetchCovers();
      coverUrls = urls;
      const all = [...urls, ...FALLBACK_ORBS];
      await Promise.all(all.map(url => new Promise(resolve => {
        if (preloadedImages.has(url)) return resolve();
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { preloadedImages.set(url, img); resolve(); };
        img.onerror = () => resolve();
        img.src = url;
      })));
    }

    function getRandomCover() {
      const urls = coverUrls.length > 0 ? coverUrls : FALLBACK_ORBS;
      return urls[Math.floor(Math.random() * urls.length)];
    }

    function addOrb() {
      const rect = getRect();
      const scale = MIN_SCALE + Math.random() * (MAX_SCALE - MIN_SCALE);
      const radius = BASE_RADIUS * scale;
      const posX = Math.random() * (rect.width - radius * 2) + radius;
      const posY = -radius * 2 - Math.random() * 400;
      const imageUrl = getRandomCover();
      const orb = Matter.Bodies.circle(posX, posY, radius, {
        restitution: 0.6, friction: 0.05, frictionAir: DAMPING,
        density: 0.001, label: 'orb', slop: 0.01,
      });
      const data = { imageUrl, image: preloadedImages.get(imageUrl) || null };
      if (!data.image) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { data.image = img; preloadedImages.set(imageUrl, img); };
        img.src = imageUrl;
      }
      orbDataMap.set(orb.id, data);
      Matter.Composite.add(engine.world, orb);
    }

    async function init() {
      await preloadImages();
      await new Promise(resolve => {
        const img = new Image();
        img.onload = () => { overlayImage = img; resolve(); };
        img.onerror = () => resolve();
        img.src = '/orb-overlay.png';
      });

      const rect = getRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);

      engine = Matter.Engine.create({ gravity: { x: 0, y: 1 }, enableSleeping: false });
      engine.positionIterations = 6;
      engine.velocityIterations = 4;

      const wallT = 50;
      const w = rect.width; const h = rect.height;
      walls = [
        Matter.Bodies.rectangle(w / 2, h + wallT / 2, w * 2, wallT, { isStatic: true, label: 'wall' }),
        Matter.Bodies.rectangle(-wallT / 2, h / 2, wallT, h * 2, { isStatic: true, label: 'wall' }),
        Matter.Bodies.rectangle(w + wallT / 2, h / 2, wallT, h * 2, { isStatic: true, label: 'wall' }),
      ];
      Matter.Composite.add(engine.world, walls);

      // Mouse constraint for dragging orbs
      const mouse = Matter.Mouse.create(canvas);
      mouse.pixelRatio = dpr;
      const mouseConstraint = Matter.MouseConstraint.create(engine, {
        mouse, constraint: { stiffness: 0.2, render: { visible: false } },
      });
      Matter.Composite.add(engine.world, mouseConstraint);

      // Drop 30 orbs with staggered timing
      for (let i = 0; i < DROP_COUNT; i++) {
        setTimeout(() => addOrb(), i * 60);
      }

      // Track mouse position relative to container for repulsion
      container.addEventListener('mousemove', e => {
        const r = getRect();
        mousePos.x = e.clientX - r.left;
        mousePos.y = e.clientY - r.top;
      });
      container.addEventListener('mouseleave', () => {
        mousePos.x = -9999; mousePos.y = -9999;
      });

      function render() {
        const rect = getRect();
        const w = rect.width; const h = rect.height;
        ctx.clearRect(0, 0, w, h);

        const orbs = Matter.Composite.allBodies(engine.world).filter(b => b.label === 'orb');

        // Apply mouse repulsion force
        if (mousePos.x > 0 && mousePos.y > 0) {
          orbs.forEach(body => {
            const dx = body.position.x - mousePos.x;
            const dy = body.position.y - mousePos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < MOUSE_RADIUS && dist > 1) {
              const force = MOUSE_FORCE * (1 - dist / MOUSE_RADIUS);
              Matter.Body.applyForce(body, body.position, {
                x: (dx / dist) * force,
                y: (dy / dist) * force,
              });
            }
          });
        }

        orbs.forEach(body => {
          const data = orbDataMap.get(body.id);
          const radius = body.circleRadius || BASE_RADIUS;
          ctx.save();
          ctx.translate(body.position.x, body.position.y);
          ctx.rotate(body.angle);
          ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI * 2); ctx.closePath(); ctx.clip();
          if (data?.image) { ctx.drawImage(data.image, -radius, -radius, radius * 2, radius * 2); }
          else { ctx.fillStyle = '#ddd'; ctx.fill(); }
          ctx.restore();
          if (overlayImage) {
            ctx.save();
            ctx.translate(body.position.x, body.position.y);
            ctx.rotate(body.angle);
            ctx.drawImage(overlayImage, -radius, -radius, radius * 2, radius * 2);
            ctx.restore();
          }
        });

        Matter.Engine.update(engine, 1000 / 60);
        requestAnimationFrame(render);
      }
      render();

      function handleResize() {
        const rect = getRect(); const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
        ctx.resetTransform(); ctx.scale(dpr, dpr);
        const wallT = 50;
        Matter.Body.setPosition(walls[0], { x: rect.width / 2, y: rect.height + wallT / 2 });
        Matter.Body.setPosition(walls[1], { x: -wallT / 2, y: rect.height / 2 });
        Matter.Body.setPosition(walls[2], { x: rect.width + wallT / 2, y: rect.height / 2 });
      }
      window.addEventListener('resize', handleResize);
    }

    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) { observer.disconnect(); init(); }
    }, { threshold: 0.1 });
    observer.observe(container);
  })();
  </script>
</body>
</html>
